import {createWriteStream} from 'fs'
import {pipeline} from 'stream'
import {createServer, connect} from 'net'
//const mqtt_pkt = require('mqtt-packet')

import {mqtt_session} from 'u8-mqtt-packet'

const mitm_port = parseInt(process.argv.slice(2).pop() || 1884)

createServer()
  .on @ 'error', @\ err ::
    console.warn @ 'Error on server:', err

  .on @ 'listening', @::
    console.log @ 'Ready'

  .on @ 'connection', @\ sock_src ::
    console.log @ 'Host Conn', typeof sock_src

    const sock_dst = connect @ 1883, '127.0.0.1', @::
      console.log @ 'MQTT Conn', typeof sock_dst

      const ts_log = createWriteStream @
        `logs/mqtt.${Date.now().toString(36)}.log.json`

      const info = @{} mitm_port
      ts_log.write @ `{"info":${JSON.stringify(info)}, "mqtt_log":[\n`


      pipeline @
        sock_src

        async function *(stream) ::
          const [mqtt_decode, mqtt_encode] = mqtt_session()
          for await let chunk of stream ::
            ts_log.write @ `  {"cs": "${chunk.toString('hex')}"},\n`
            // so we don't see Buffer instances
            chunk = new Uint8Array(chunk)

            for const pkt of mqtt_decode(chunk) ::
              const {type_obj, u8_body, ...tip} = pkt
              ts_log.write @ `  {"cst": "${type_obj.type}"},\n`
              if 1 ::
                console.log @ '==>', type_obj.type, tip
              //else rt_pkt(type_obj, tip)

              yield chunk

        sock_dst

        async function *(stream) ::
          const [mqtt_decode, mqtt_encode] = mqtt_session()
          for await let chunk of stream ::
            ts_log.write @ `  {"sc": "${chunk.toString('hex')}"},\n`
             // so we don't see Buffer instances
            chunk = new Uint8Array(chunk)


            for const pkt of mqtt_decode(chunk) ::
              const {type_obj, u8_body, ...tip} = pkt
              ts_log.write @ `  {"sct": "${type_obj.type}"},\n`
              if 1 ::
                console.log @ '<--', type_obj.type, tip
              //else rt_pkt(type_obj, tip)

              yield chunk

        sock_src

        @\ err ::>
          ts_log.write @ `  null ]}\n`
          ts_log.end()

          sock_dst.end()
          sock_src.end()

          if err ::
            console.warn @ 'Error at end of pipeline:', err

  .listen @ mitm_port


/*
function rt_pkt(type_obj, tip) ::
  const rt_pkt = mqtt_encode(type_obj.type, tip)
  if undefined === rt_pkt ::
    console.log @ 'No RT', type_obj
    return

  const diff = rt_pkt.map @\ v,i => v === u8_raw_pkt[i] ? 0 : 1
  const eq = u8_raw_pkt.byteLength === rt_pkt.byteLength 
    && ! diff.some(Boolean)

  console.group @ 'RT', eq, type_obj
  if ! eq ::
    console.log @ 'tip', tip
    console.log @ 'rt_pkt', rt_pkt
    console.log @ 'or_pkt', u8_raw_pkt
    console.log @ 'diff', diff

    mqtt_pkt.parser()
    .on @ 'packet', pkt_o =>
      console.log @ '3p', pkt_o
    .parse @ Buffer.from(u8_raw_pkt)

  console.groupEnd()
*/
