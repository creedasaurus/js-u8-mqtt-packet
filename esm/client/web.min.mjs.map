{"version":3,"file":"web.min.mjs","sources":["../../code/mqtt_varint.jsy","../../code/mqtt_props.jsy","../../code/decode/_utils.jsy","../../code/decode/connect.jsy","../../code/decode/connack.jsy","../../code/decode/puback.jsy","../../code/decode/pubrec.jsy","../../code/decode/subscribe.jsy","../../code/decode/suback.jsy","../../code/decode/unsuback.jsy","../../code/decode/disconnect.jsy","../../code/decode/auth.jsy","../../code/_decode_all.jsy","../../code/decode/publish.jsy","../../code/decode/unsubscribe.jsy","../../code/encode/_utils.jsy","../../code/encode/_pkt_writer.jsy","../../code/encode/connect.jsy","../../code/encode/connack.jsy","../../code/encode/pubrec.jsy","../../code/encode/subscribe.jsy","../../code/encode/suback.jsy","../../code/_encode_all.jsy","../../code/encode/publish.jsy","../../code/encode/puback.jsy","../../code/encode/pubrel.jsy","../../code/encode/pubcomp.jsy","../../code/encode/unsubscribe.jsy","../../code/encode/unsuback.jsy","../../code/encode/pingreq.jsy","../../code/encode/pingresp.jsy","../../code/encode/disconnect.jsy","../../code/encode/auth.jsy","../../code/mqtt_cmds.jsy","../../code/framing.jsy","../../code/_session_all.jsy","../../code/session.jsy","../../code/client/web.jsy","../../code/client/core.jsy","../../code/client/core_web.jsy"],"sourcesContent":["export function encode_varint(n, a=[]) ::\n  do ::\n    const ni = n & 0x7f\n    n >>>= 7\n    a.push @ ni | (0===n ? 0 : 0x80)\n  while n > 0\n  return a\n\n\nexport function decode_varint_loop(u8, vi=0, vi_tuple=[]) ::\n  let shift = 0, n = (u8[vi] & 0x7f)\n  while 0x80 & u8[vi++] ::\n    n |= (u8[vi] & 0x7f) << (shift += 7)\n\n  vi_tuple[0] = n\n  vi_tuple[1] = vi\n  return vi_tuple\n\n\nexport function decode_varint(u8, vi=0, vi_tuple=[]) ::\n  // unrolled for a max of 4 chains\n  let n = (u8[vi] & 0x7f) <<  0\n  if 0x80 & u8[vi++] ::\n    n |= (u8[vi] & 0x7f) <<  7\n    if 0x80 & u8[vi++] ::\n      n |= (u8[vi] & 0x7f) << 14\n      if 0x80 & u8[vi++] ::\n        n |= (u8[vi] & 0x7f) << 21\n\n  vi_tuple[0] = n\n  vi_tuple[1] = vi\n  return vi_tuple\n\n","\nexport const [mqtt_props_by_id, mqtt_props_entries] = @!\n  const entries = @[]\n    @[] 0x01, 'u8',   'payload_format_indicator'\n    @[] 0x02, 'u32',  'message_expiry_interval', \n    @[] 0x03, 'utf8', 'content_type', \n    @[] 0x08, 'utf8', 'response_topic', \n    @[] 0x09, 'bin',  'correlation_data', \n    @[] 0x0B, 'vint', 'subscription_identifier', \n    @[] 0x11, 'u32',  'session_expiry_interval', \n    @[] 0x12, 'utf8', 'assigned_client_identifier', \n    @[] 0x13, 'u16',  'server_keep_alive', \n    @[] 0x15, 'utf8', 'authentication_method', \n    @[] 0x16, 'bin',  'authentication_data', \n    @[] 0x17, 'u8',   'request_problem_information', \n    @[] 0x18, 'u32',  'will_delay_interval', \n    @[] 0x19, 'u8',   'request_response_information', \n    @[] 0x1A, 'utf8', 'response_information', \n    @[] 0x1C, 'utf8', 'server_reference', \n    @[] 0x1F, 'utf8', 'reason_string', \n    @[] 0x21, 'u16',  'receive_maximum', \n    @[] 0x22, 'u16',  'topic_alias_maximum', \n    @[] 0x23, 'u16',  'topic_alias', \n    @[] 0x24, 'u8',   'maximum_qo_s', \n    @[] 0x25, 'u8',   'retain_available', \n    @[] 0x26, 'pair', 'user_properties', true\n    @[] 0x27, 'u32',  'maximum_packet_size', \n    @[] 0x28, 'u8',   'wildcard_subscription_available', \n    @[] 0x29, 'u8',   'subscription_identifiers_available', true\n    @[] 0x2A, 'u8',   'shared_subscription_available', \n\n\n  const prop_map = new Map()\n  for const [id, type, name, plural] of entries ::\n    const prop_obj = {id, type, name}\n    if plural :: prop_obj.plural = plural\n    prop_map.set(prop_obj.id, prop_obj)\n    prop_map.set(prop_obj.name, prop_obj)\n\n  return @[]\n    prop_map.get.bind(prop_map)\n    Array.from @ prop_map.values()\n","import {decode_varint} from '../mqtt_varint.jsy'\nimport {mqtt_props_by_id} from '../mqtt_props.jsy'\n\n\nexport class mqtt_type_reader ::\n  constructor(buf, idx=0) ::\n    this.buf = buf\n    this.step = (width, r) => @ r = idx, idx += width, r\n\n  has_more() ::\n    const {buf, step} = this\n    return buf.byteLength > step(0)\n\n  u8() ::\n    const {buf, step} = this\n    return buf[step(1)]\n\n  u16() ::\n    const {buf, step} = this\n    const i = step(2)\n    return (buf[i]<<8) | buf[i+1]\n\n  u32() ::\n    const {buf, step} = this\n    const i = step(4)\n    return (buf[i]<<24) | (buf[i+1]<<16) | (buf[i+2]<<8) | buf[i+3]\n\n  vint() ::\n    const {buf, step} = this\n    const [n, vi] = decode_varint(buf, step(0))\n    step(vi)\n    return n\n\n  bin() ::\n    const {buf, step} = this\n    const i = step(2)\n    const len = (buf[i]<<8) | buf[i+1]\n    const i0 = step(len)\n    return buf.subarray(i0, i0+len)\n\n  utf8() :: return new TextDecoder('utf-8').decode @ this.bin()\n  pair() :: return @[] this.utf8(), this.utf8()\n\n  u8_flags(FlagsType) ::\n    const {buf, step} = this\n    return new FlagsType(buf[step(1)])\n\n  u8_reason(fn_reason) ::\n    const {buf, step} = this\n    return fn_reason @ buf[step(1)]\n\n  flush() ::\n    const {buf, step} = this\n    this.step = this.buf = null\n    return buf.subarray(step(0))\n\n  props() ::\n    const {buf, step} = this\n\n    const [len, vi] = decode_varint(buf, step(0))\n    const end_part = vi + len\n    step(end_part)\n    if 0 === len ::\n      return null\n\n    const prop_entries = @[]\n    const rdr = mqtt_reader @\n      buf.subarray(vi, end_part)\n\n    while rdr.has_more() ::\n      const {name, type} = mqtt_props_by_id @ rdr.u8()\n      const value = rdr[type]()\n      prop_entries.push @# name, value\n\n    return prop_entries\n\n\n\nclass U8_Reason extends Number ::\n  constructor(u8, reason) ::\n    super(u8)\n    this.reason = reason\n\nexport function bind_reason_lookup(reason_entries) ::\n  const reason_map = new Map()\n  for const [u8, reason] of reason_entries ::\n    reason_map.set @ u8, new U8_Reason(u8, reason)\n\n  return reason_map.get.bind(reason_map)\n\n","import {mqtt_type_reader} from './_utils.jsy'\n\nclass _connect_flags_ extends Number ::\n  get reserved() :: return this & 0x01 !== 0\n  get clean_start() :: return this & 0x02 !== 0\n  get will_flag() :: return this & 0x04 !== 0\n  get will_qos() :: return (this >>> 3) & 0x3\n  get will_retain() :: return this & 0x20 !== 0\n  get password() :: return this & 0x40 !== 0\n  get username() :: return this & 0x80 !== 0\n\n\nexport function mqtt_decode_connect(pkt) ::\n  const rdr = new mqtt_type_reader(pkt.u8_body, 0)\n  if 'MQTT' !== rdr.utf8() ::\n    throw new Error @ 'Invalid mqtt_connect packet'\n\n  pkt._base_.mqtt_level = pkt.mqtt_level = rdr.u8()\n\n  const flags = pkt.connect_flags =\n    rdr.u8_flags(_connect_flags_)\n\n  pkt.keep_alive = rdr.u16()\n\n  if 5 <= pkt.mqtt_level ::\n    pkt.props = rdr.props()\n\n\n\n  const payload = pkt.payload = {}\n  payload.client_id = rdr.utf8()\n  if flags.will_flag ::\n    if 5 <= pkt.mqtt_level ::\n      payload.will_properties = rdr.props()\n\n    payload.will_topic = rdr.utf8()\n    payload.will_payload = rdr.bin()\n\n  if flags.username ::\n    payload.username = rdr.utf8()\n\n  if flags.password ::\n    payload.password = rdr.bin()\n  return pkt\n\n","import {mqtt_type_reader, bind_reason_lookup} from './_utils.jsy'\n\nclass _connack_flags_ extends Number ::\n  get session_present() :: return this & 0x01 !== 0\n\nexport const _connack_reason_ = bind_reason_lookup @#\n  // MQTT 3.1.1\n  @[] 0x00, 'Success'\n  @[] 0x01, 'Connection refused, unacceptable protocol version'\n  @[] 0x02, 'Connection refused, identifier rejected'\n  @[] 0x03, 'Connection refused, server unavailable'\n  @[] 0x04, 'Connection refused, bad user name or password'\n  @[] 0x05, 'Connection refused, not authorized'\n\n  // MQTT 5.0\n  @[] 0x81, 'Malformed Packet'\n  @[] 0x82, 'Protocol Error'\n  @[] 0x83, 'Implementation specific error'\n  @[] 0x84, 'Unsupported Protocol Version'\n  @[] 0x85, 'Client Identifier not valid'\n  @[] 0x86, 'Bad User Name or Password'\n  @[] 0x87, 'Not authorized'\n  @[] 0x88, 'Server unavailable'\n  @[] 0x89, 'Server busy'\n  @[] 0x8A, 'Banned'\n  @[] 0x8C, 'Bad authentication method'\n  @[] 0x90, 'Topic Name invalid'\n  @[] 0x95, 'Packet too large'\n  @[] 0x97, 'Quota exceeded'\n  @[] 0x99, 'Payload format invalid'\n  @[] 0x9A, 'Retain not supported'\n  @[] 0x9B, 'QoS not supported'\n  @[] 0x9C, 'Use another server'\n  @[] 0x9D, 'Server moved'\n  @[] 0x9F, 'Connection rate exceeded'\n\n\nexport function mqtt_decode_connack(pkt) ::\n  const rdr = new mqtt_type_reader(pkt.u8_body, 0)\n\n  const flags = pkt.connect_flags =\n    rdr.u8_flags(_connack_flags_)\n\n  pkt.reason = rdr.u8_reason(_connack_reason_)\n  if 5 <= pkt.mqtt_level ::\n    pkt.props = rdr.props()\n  return pkt\n\n","import {mqtt_type_reader, bind_reason_lookup} from './_utils.jsy'\n\nexport const _puback_reason_ = bind_reason_lookup @#\n  @[] 0x00, 'Success'\n\n  // MQTT 5.0\n  @[] 0x10, 'No matching subscribers'\n  @[] 0x80, 'Unspecified error'\n  @[] 0x83, 'Implementation specific error'\n  @[] 0x87, 'Not authorized'\n  @[] 0x90, 'Topic Name invalid'\n  @[] 0x91, 'Packet identifier in use'\n  @[] 0x97, 'Quota exceeded'\n  @[] 0x99, 'Payload format invalid'\n\n\nexport function mqtt_decode_puback(pkt) ::\n  const rdr = new mqtt_type_reader(pkt.u8_body, 0)\n\n  pkt.pkt_id = rdr.u16()\n  if 5 <= pkt.mqtt_level ::\n    pkt.reason = rdr.u8_reason(_puback_reason_)\n    pkt.props = rdr.props()\n\n  return pkt\n\n","import {mqtt_type_reader, bind_reason_lookup} from './_utils.jsy'\n\nexport const _pubxxx_reason_ = bind_reason_lookup @#\n  @[] 0x00, 'Success'\n  @[] 0x92, 'Packet Identifier not found'\n\n\nexport {_mqtt_decode_pubxxx as mqtt_decode_pubrec}\n\nexport function _mqtt_decode_pubxxx(pkt) ::\n  const rdr = new mqtt_type_reader(pkt.u8_body, 0)\n\n  pkt.pkt_id = rdr.u16()\n  pkt.reason = rdr.u8_reason(_pubxxx_reason_)\n  if 5 <= pkt.mqtt_level ::\n    pkt.props = rdr.props()\n  return pkt\n\n","import {mqtt_type_reader} from './_utils.jsy'\n\nclass _subscription_options_ extends Number ::\n  get qos() :: return this & 0x3\n  get retain() :: return this & 0x4 !== 0\n  get retain_handling() :: return (this >> 2) & 0x3\n\nexport function mqtt_decode_subscribe(pkt) ::\n  const rdr = new mqtt_type_reader(pkt.u8_body, 0)\n\n  pkt.pkt_id = rdr.u16()\n  if 5 <= pkt.mqtt_level ::\n    pkt.props = rdr.props()\n\n  const topic_list = pkt.sub_topics = []\n  while rdr.has_more() ::\n    topic_list.push @:\n      topic: rdr.utf8()\n      opts: rdr.u8_flags(_subscription_options_)\n\n  return pkt\n\n","import {mqtt_type_reader, bind_reason_lookup} from './_utils.jsy'\n\nexport const _suback_reason_ = bind_reason_lookup @#\n  // MQTT 3.1.1\n  @[] 0x00, 'Granted QoS 0'\n  @[] 0x01, 'Granted QoS 1'\n  @[] 0x02, 'Granted QoS 2'\n\n  // MQTT 5.0\n  @[] 0x80, 'Unspecified error'\n  @[] 0x83, 'Implementation specific error'\n  @[] 0x87, 'Not authorized'\n  @[] 0x8F, 'Topic Filter invalid'\n  @[] 0x91, 'Packet Identifier in use'\n  @[] 0x97, 'Quota exceeded'\n  @[] 0x9E, 'Shared Subscriptions not supported'\n  @[] 0xA1, 'Subscription Identifiers not supported'\n  @[] 0xA2, 'Wildcard Subscriptions not supported'\n\n\nexport function mqtt_decode_suback(pkt) ::\n  return _mqtt_decode_suback @\n    pkt, _suback_reason_, 'sub_answers'\n\n\nexport function _mqtt_decode_suback(pkt, _ack_reason_, key_answers) ::\n  const rdr = new mqtt_type_reader(pkt.u8_body, 0)\n\n  pkt.pkt_id = rdr.u16()\n  if 5 <= pkt.mqtt_level ::\n    pkt.props = rdr.props()\n\n  const answers = pkt[key_answers] = []\n  while rdr.has_more() ::\n    answers.push @\n      rdr.u8_reason(_ack_reason_)\n\n  return pkt\n\n","import {bind_reason_lookup} from './_utils.jsy'\nimport {_mqtt_decode_suback} from './suback.jsy'\n\nexport const _unsuback_reason_ = bind_reason_lookup @#\n  @[] 0x00, 'Success'\n  @[] 0x11, 'No subscription existed'\n  @[] 0x80, 'Unspecified error'\n  @[] 0x83, 'Implementation specific error'\n  @[] 0x87, 'Not authorized'\n  @[] 0x8F, 'Topic Filter invalid'\n  @[] 0x91, 'Packet Identifier in use'\n\nexport function mqtt_decode_unsuback(pkt) ::\n  return _mqtt_decode_suback @\n    pkt, _unsuback_reason_, 'unsub_answers'\n\n","import {mqtt_type_reader, bind_reason_lookup} from './_utils.jsy'\n\nexport const _disconnect_reason_ = bind_reason_lookup @#\n  // MQTT 5.0\n  @[] 0x00, 'Normal disconnection'\n  @[] 0x04, 'Disconnect with Will Message'\n  @[] 0x80, 'Unspecified error'\n  @[] 0x81, 'Malformed Packet'\n  @[] 0x82, 'Protocol Error'\n  @[] 0x83, 'Implementation specific error'\n  @[] 0x87, 'Not authorized'\n  @[] 0x89, 'Server busy'\n  @[] 0x8B, 'Server shutting down'\n  @[] 0x8D, 'Keep Alive timeout'\n  @[] 0x8E, 'Session taken over'\n  @[] 0x8F, 'Topic Filter invalid'\n  @[] 0x90, 'Topic Name invalid'\n  @[] 0x93, 'Receive Maximum exceeded'\n  @[] 0x94, 'Topic Alias invalid'\n  @[] 0x95, 'Packet too large'\n  @[] 0x96, 'Message rate too high'\n  @[] 0x97, 'Quota exceeded'\n  @[] 0x98, 'Administrative action'\n  @[] 0x99, 'Payload format invalid'\n  @[] 0x9A, 'Retain not supported'\n  @[] 0x9B, 'QoS not supported'\n  @[] 0x9C, 'Use another server'\n  @[] 0x9D, 'Server moved'\n  @[] 0x9E, 'Shared Subscriptions not supported'\n  @[] 0x9F, 'Connection rate exceeded'\n  @[] 0xA0, 'Maximum connect time'\n  @[] 0xA1, 'Subscription Identifiers not supported'\n  @[] 0xA2, 'Wildcard Subscriptions not supported'\n\n\nexport function mqtt_decode_disconnect(pkt) ::\n  if 5 <= pkt.mqtt_level ::\n    const rdr = new mqtt_type_reader(pkt.u8_body, 0)\n    pkt.reason = rdr.u8_reason(_disconnect_reason_)\n    pkt.props = rdr.props()\n  return pkt\n\n","import {mqtt_type_reader, bind_reason_lookup} from './_utils.jsy'\n\nexport const _auth_reason_ = bind_reason_lookup @#\n  // MQTT 5.0\n  @[] 0x00, 'Success'\n  @[] 0x18, 'Continue authentication'\n  @[] 0x19, 'Re-authenticate'\n\nexport function mqtt_decode_auth(pkt) ::\n  if 5 <= pkt.mqtt_level ::\n    const rdr = new mqtt_type_reader(pkt.u8_body, 0)\n    pkt.reason = rdr.u8_reason(_auth_reason_)\n    pkt.props = rdr.props()\n  return pkt\n\n","import {mqtt_decode_connect} from './decode/connect.jsy'\nimport {mqtt_decode_connack} from './decode/connack.jsy'\nimport {mqtt_decode_publish} from './decode/publish.jsy'\nimport {mqtt_decode_puback} from './decode/puback.jsy'\nimport {mqtt_decode_pubrec} from './decode/pubrec.jsy'\nimport {mqtt_decode_pubrel} from './decode/pubrel.jsy'\nimport {mqtt_decode_pubcomp} from './decode/pubcomp.jsy'\nimport {mqtt_decode_subscribe} from './decode/subscribe.jsy'\nimport {mqtt_decode_suback} from './decode/suback.jsy'\nimport {mqtt_decode_unsubscribe} from './decode/unsubscribe.jsy'\nimport {mqtt_decode_unsuback} from './decode/unsuback.jsy'\nimport {mqtt_decode_disconnect} from './decode/disconnect.jsy'\nimport {mqtt_decode_auth} from './decode/auth.jsy'\n\nexport * from './decode/_utils.jsy'\n\nfunction mqtt_dnu_decode(pkt) ::\n  const err = new Error @ 'MQTT packet not understood'\n  err.pkt = pkt\n  throw err\n\nconst mqtt_decode_noop = pkt => pkt\n\n\nexport const mqtt_decode_ops_by_id = @[]\n  mqtt_dnu_decode\n  mqtt_decode_connect\n  mqtt_decode_connack\n  mqtt_decode_publish\n  mqtt_decode_puback\n  mqtt_decode_pubrec\n  mqtt_decode_pubrel\n  mqtt_decode_pubcomp\n  mqtt_decode_subscribe\n  mqtt_decode_suback\n  mqtt_decode_unsubscribe\n  mqtt_decode_unsuback\n  mqtt_decode_noop // mqtt_decode_pingreq\n  mqtt_decode_noop // mqtt_decode_pingresp\n  mqtt_decode_disconnect\n  mqtt_decode_auth\n\n\nexport @{}\n  mqtt_dnu_decode,\n  mqtt_decode_connect,\n  mqtt_decode_connack,\n  mqtt_decode_publish,\n  mqtt_decode_puback,\n  mqtt_decode_pubrec,\n  mqtt_decode_pubrel,\n  mqtt_decode_pubcomp,\n  mqtt_decode_subscribe,\n  mqtt_decode_suback,\n  mqtt_decode_unsubscribe,\n  mqtt_decode_unsuback,\n  mqtt_decode_noop as mqtt_decode_pingreq,\n  mqtt_decode_noop as mqtt_decode_pingresp,\n  mqtt_decode_disconnect,\n  mqtt_decode_auth,\n  mqtt_decode_noop\n\n","import {mqtt_type_reader} from './_utils.jsy'\n\nexport function mqtt_decode_publish(pkt) ::\n  const {hdr} = pkt\n  pkt.dup = Boolean(hdr & 0x8)\n  pkt.retain = Boolean(hdr & 0x1)\n  const qos = pkt.qos = (hdr>>1) & 0x3\n\n  const rdr = new mqtt_type_reader(pkt.u8_body, 0)\n  pkt.topic = rdr.utf8()\n  if 0 !== qos ::\n    pkt.pkt_id = rdr.u16()\n\n  if 5 <= pkt.mqtt_level ::\n    pkt.props = rdr.props()\n    pkt.payload = rdr.flush()\n  else ::\n    pkt.payload = rdr.flush()\n\n  return pkt\n\n","import {mqtt_type_reader} from './_utils.jsy'\n\nexport function mqtt_decode_unsubscribe(pkt) ::\n  const rdr = new mqtt_type_reader(pkt.u8_body, 0)\n\n  pkt.pkt_id = rdr.u16()\n  if 5 <= pkt.mqtt_level ::\n    pkt.props = rdr.props()\n\n  const topic_list = pkt.unsub_topics = []\n  while rdr.has_more() ::\n    topic_list.push @ rdr.utf8()\n\n  return pkt\n\n","import {encode_varint} from '../mqtt_varint.jsy'\n//import {mqtt_props_by_id} from '../mqtt_props.jsy'\nimport {mqtt_pkt_writer_pool} from './_pkt_writer.jsy'\n\nexport * from './_pkt_writer.jsy'\n\nconst pack_utf8 = v => new TextEncoder('utf-8').encode(v)\nconst pack_u16 = v => @[] (v>>>8) & 0xff, v & 0xff\nconst pack_u32 = v => @[] (v>>>24) & 0xff, (v>>>16) & 0xff, (v>>>8) & 0xff, v & 0xff\n\nexport class mqtt_type_writer ::\n  constructor() ::\n    Object.assign @ this, this._pkt_writer()\n\n  u8(v) :: this.push @# v & 0xff\n  u16(v) :: this.push @ pack_u16(v)\n  u32(v) :: this.push @ pack_u32(v)\n  vint(v) :: this.push @ encode_varint(v)\n\n  _u16_bin(u8_buf) ::\n    const {push} = this\n    push @ pack_u16 @ u8_buf.byteLength\n    push @ u8_buf\n\n  flush(buf) ::\n    this.push @\n      'string' === typeof buf\n        ? pack_utf8(buf) : buf\n\n    this.push = false\n\n  bin(u8_buf) ::\n    if 'string' === typeof u8_buf ::\n      return this.utf8(u8_buf)\n\n    if u8_buf.length !== u8_buf.byteLength ::\n      u8_buf = new Uint8Array(u8_buf)\n    this._u16_bin(u8_buf)\n\n  utf8(v) :: this._u16_bin @\n    new TextEncoder('utf-8').encode(v)\n\n  pair(k,v) ::\n    this.utf8(k)\n    this.utf8(v)\n\n  u8_flags(v, enc_flags) ::\n    if undefined !== v && isNaN(+v) ::\n      v = enc_flags(v, 0)\n    v |= 0\n    this.push @# v\n    return v\n\n  u8_reason(v) :: this.push @# v | 0\n\n  props() :: throw \"TODO\"\n\nmqtt_type_writer.prototype._pkt_writer = \n  mqtt_pkt_writer_pool()\n","import {encode_varint} from '../mqtt_varint.jsy'\n\nexport function mqtt_pkt_writer_pool() ::\n  const _pool_ = []\n  return @=> 0 === _pool_.length\n      ? mqtt_pkt_writer(_pool_)\n      : _pool_.pop()\n\nexport function mqtt_pkt_writer(_pool_) ::\n  let self, n=0, rope=[]\n  return self = @{}\n    push(u8) ::\n      #IF DEBUG\n        u8 = new Uint8Array(u8)\n\n      rope.push(u8)\n      n += u8.length\n\n    as_pkt(hdr) ::\n      const pkt = _mqtt_pkt_rope(hdr, n, rope)\n      n=0; rope=[]\n      if undefined !== _pool_ ::\n        _pool_.push(self)\n      return pkt\n\nexport function _mqtt_pkt_rope(hdr, n, rope) ::\n  const header = encode_varint(n, [hdr])\n  let i = header.length\n\n  const pkt = new Uint8Array(n + i)\n  pkt.set(header, 0)\n  for const vec of rope ::\n    pkt.set(vec, i)\n    i += vec.length\n  return pkt\n\n","import {mqtt_type_writer} from './_utils.jsy'\n\nconst _c_mqtt_proto = new Uint8Array @#\n  0, 4, 0x4d, 0x51, 0x54, 0x54\n\nexport function mqtt_encode_connect(mqtt_level, pkt) ::\n  const wrt = new mqtt_type_writer()\n\n  wrt.push(_c_mqtt_proto)\n  wrt.u8 @ mqtt_level\n  const flags = wrt.u8_flags @\n    pkt.connect_flags\n    _enc_connect_flags\n\n  wrt.u16(pkt.keep_alive)\n\n  if 5 <= mqtt_level ::\n    wrt.props(pkt.props)\n\n\n  const {payload} = pkt\n  wrt.utf8 @ payload.client_id\n  if flags & 0x04 :: // .will_flag\n    if 5 <= mqtt_level ::\n      wrt.props @ payload.will_properties\n\n    wrt.utf8 @ payload.will_topic\n    wrt.bin @ payload.will_payload\n\n  if flags & 0x80 :: // .username\n    wrt.utf8 @ payload.username\n\n  if flags & 0x40 :: // .password\n    wrt.bin @ payload.password\n\n  return wrt.as_pkt(0x10)\n\nconst _enc_connect_flags = flags => 0\n    | @ flags.reserved ? 0x01 : 0\n    | @ (flags.will_qos & 0x3) << 3\n    | @ flags.clean_start ? 0x02 : 0\n    | @ flags.will_flag ? 0x04 : 0\n    | @ flags.will_retain ? 0x20 : 0\n    | @ flags.password ? 0x40 : 0\n    | @ flags.username ? 0x80 : 0\n","import {mqtt_type_writer} from './_utils.jsy'\n\nexport function mqtt_encode_connack(mqtt_level, pkt) ::\n  const wrt = new mqtt_type_writer()\n\n  const {connect_flags} = pkt\n  wrt.u8_flags @ pkt.connect_flags, _enc_flags_connack\n\n  if 5 <= mqtt_level ::\n    wrt.u8_reason @ pkt.reason\n    wrt.props @ pkt.props\n\n  else ::\n    wrt.u8_reason @ pkt.return_code || pkt.reason\n\n  return wrt.as_pkt(0x20)\n\nconst _enc_flags_connack = connect_flags =>\n  connect_flags.session_present ? 1 : 0\n\n","import {mqtt_type_writer} from './_utils.jsy'\n\nexport function mqtt_encode_pubrec(mqtt_level, pkt) ::\n  return _mqtt_encode_pubxxx @ 0x50, mqtt_level, pkt\n\nexport function _mqtt_encode_pubxxx(hdr, mqtt_level, pkt) ::\n  const wrt = new mqtt_type_writer()\n\n  wrt.u16(pkt.pkt_id)\n  if 5 <= mqtt_level ::\n    wrt.props(pkt.props)\n    wrt.u8_reason @ pkt.reason\n\n  else ::\n    wrt.u8_reason @ pkt.return_code || pkt.reason\n\n  return wrt.as_pkt(hdr)\n\n","import {mqtt_type_writer} from './_utils.jsy'\n\nexport function mqtt_encode_subscribe(mqtt_level, pkt) ::\n  const wrt = new mqtt_type_writer()\n\n  wrt.u16(pkt.pkt_id)\n  if 5 <= pkt.mqtt_level ::\n    wrt.props(pkt.props)\n\n  for const each of pkt.sub_topics ::\n    if 'string' === typeof each ::\n      wrt.utf8(each)\n      wrt.u8(0)\n\n    else if Array.isArray(each) ::\n      wrt.utf8(each[0])\n      wrt.u8_flags(each[1], _enc_subscribe_flags)\n\n    else ::\n      wrt.utf8(each.topic)\n      wrt.u8_flags(each.opts, _enc_subscribe_flags)\n\n  return wrt.as_pkt(0x82)\n\nconst _enc_subscribe_flags = opts => 0\n    | @ opts.qos & 0x3\n    | @ opts.retain ? 0x4 : 0\n    | @ (opts.retain_handling & 0x3) << 2  \n\n","import {mqtt_type_writer} from './_utils.jsy'\n\nexport function mqtt_encode_suback(mqtt_level, pkt) ::\n  return _mqtt_encode_suback @\n    0x90, mqtt_level, pkt, 'sub_answers'\n\n\nexport function _mqtt_encode_suback(hdr, mqtt_level, pkt, key_answers) ::\n  const wrt = new mqtt_type_writer()\n\n  wrt.u16 @ pkt.pkt_id\n  if 5 <= pkt.mqtt_level ::\n    wrt.props @ pkt.props\n\n  for const ans of pkt[key_answers] ::\n    wrt.u8_reason(ans)\n\n  return wrt.as_pkt(hdr)\n","import {mqtt_encode_connect} from './encode/connect.jsy'\nimport {mqtt_encode_connack} from './encode/connack.jsy'\nimport {mqtt_encode_publish} from './encode/publish.jsy'\nimport {mqtt_encode_puback} from './encode/puback.jsy'\nimport {mqtt_encode_pubrec} from './encode/pubrec.jsy'\nimport {mqtt_encode_pubrel} from './encode/pubrel.jsy'\nimport {mqtt_encode_pubcomp} from './encode/pubcomp.jsy'\nimport {mqtt_encode_subscribe} from './encode/subscribe.jsy'\nimport {mqtt_encode_suback} from './encode/suback.jsy'\nimport {mqtt_encode_unsubscribe} from './encode/unsubscribe.jsy'\nimport {mqtt_encode_unsuback} from './encode/unsuback.jsy'\nimport {mqtt_encode_pingreq} from './encode/pingreq.jsy'\nimport {mqtt_encode_pingresp} from './encode/pingresp.jsy'\nimport {mqtt_encode_disconnect} from './encode/disconnect.jsy'\nimport {mqtt_encode_auth} from './encode/auth.jsy'\n\nexport * from './encode/_utils.jsy'\n\nexport const mqtt_encode_by_type = @{}\n  connect: mqtt_encode_connect\n  connack: mqtt_encode_connack\n  publish: mqtt_encode_publish\n  puback: mqtt_encode_puback\n  pubrec: mqtt_encode_pubrec\n  pubrel: mqtt_encode_pubrel\n  pubcomp: mqtt_encode_pubcomp\n  subscribe: mqtt_encode_subscribe\n  suback: mqtt_encode_suback\n  unsubscribe: mqtt_encode_unsubscribe\n  unsuback: mqtt_encode_unsuback\n  pingreq: mqtt_encode_pingreq\n  pingresp: mqtt_encode_pingresp\n  disconnect: mqtt_encode_disconnect\n  auth: mqtt_encode_auth\n\n\nexport @{}\n  mqtt_encode_connect,\n  mqtt_encode_connack,\n  mqtt_encode_publish,\n  mqtt_encode_puback,\n  mqtt_encode_pubrec,\n  mqtt_encode_pubrel,\n  mqtt_encode_pubcomp,\n  mqtt_encode_subscribe,\n  mqtt_encode_suback,\n  mqtt_encode_unsubscribe,\n  mqtt_encode_unsuback,\n  mqtt_encode_pingreq,\n  mqtt_encode_pingresp,\n  mqtt_encode_disconnect,\n  mqtt_encode_auth,\n\n","import {mqtt_type_writer} from './_utils.jsy'\n\nexport function mqtt_encode_publish(mqtt_level, pkt) ::\n  const qos = (pkt.qos & 0x3) << 1\n  const wrt = new mqtt_type_writer()\n\n  wrt.utf8(pkt.topic)\n  if 0 !== qos ::\n    wrt.u16(pkt.pkt_id)\n\n  if 5 <= mqtt_level ::\n    wrt.props(pkt.props)\n    wrt.flush(pkt.payload)\n  else ::\n    wrt.flush(pkt.payload)\n\n  return wrt.as_pkt @\n    0x30 | qos | (pkt.dup ? 0x8 : 0) | (pkt.retain ? 0x1 : 0)\n\n","import {mqtt_type_writer} from './_utils.jsy'\n\nexport function mqtt_encode_puback(mqtt_level, pkt) ::\n  const wrt = new mqtt_type_writer()\n\n  wrt.u16(pkt.pkt_id)\n  if 5 <= mqtt_level ::\n    wrt.u8_reason(pkt.reason)\n    wrt.props(pkt.props)\n\n  return wrt.as_pkt(0x40)\n\n\n","import {_mqtt_encode_pubxxx} from './pubrec.jsy'\n\nexport function mqtt_encode_pubrel(mqtt_level, pkt) ::\n  return _mqtt_encode_pubxxx @ 0x62, mqtt_level, pkt\n","import {_mqtt_encode_pubxxx} from './pubrec.jsy'\n\nexport function mqtt_encode_pubcomp(mqtt_level, pkt) ::\n  return _mqtt_encode_pubxxx @ 0x70, mqtt_level, pkt\n\n","import {mqtt_type_writer} from './_utils.jsy'\n\nexport function mqtt_encode_unsubscribe(mqtt_level, pkt) ::\n  const wrt = new mqtt_type_writer()\n\n  wrt.u16(pkt.pkt_id)\n  if 5 <= pkt.mqtt_level ::\n    wrt.props(pkt.props)\n\n  for const topic of pkt.unsub_topics ::\n    wrt.utf8(topic)\n\n  return wrt.as_pkt(0xa2)\n\n","import {_mqtt_encode_suback} from './suback.jsy'\n\nexport function mqtt_encode_unsuback(mqtt_level, pkt) ::\n  return _mqtt_encode_suback @\n    0xb0, mqtt_level, pkt, 'unsub_answers'\n\n","export const mqtt_encode_pingreq = @=>\n  new Uint8Array @# 0xc0, 0\n","export const mqtt_encode_pingresp = @=>\n  new Uint8Array @# 0xd0, 0\n","import {mqtt_type_writer} from './_utils.jsy'\n\nexport function mqtt_encode_disconnect(mqtt_level, pkt) ::\n  const wrt = new mqtt_type_writer()\n\n  if 5 <= mqtt_level ::\n    wrt.u8_reason @ pkt.reason\n    wrt.props @ pkt.props\n\n  return wrt.as_pkt(0xe0)\n\n","import {mqtt_type_writer} from './_utils.jsy'\n\nexport function mqtt_encode_auth(mqtt_level, pkt) ::\n  if 5 > mqtt_level ::\n    throw new Error @ 'Auth packets are only available after MQTT 5.x'\n\n  const wrt = new mqtt_type_writer()\n\n  wrt.u8_reason(pkt.reason)\n  wrt.props(pkt.props)\n\n  return wrt.as_pkt(0xf0)\n\n","\nexport const [mqtt_cmd_by_type, mqtt_type_entries] = @!\n\n  const entries = @[]\n    @[] 0x0, 'reserved'\n    @[] 0x1, 'connect'\n    @[] 0x2, 'connack'\n    @[] 0x3, 'publish'\n    @[] 0x4, 'puback'\n    @[] 0x5, 'pubrec'\n    @[] 0x6, 'pubrel'\n    @[] 0x7, 'pubcomp'\n    @[] 0x8, 'subscribe'\n    @[] 0x9, 'suback'\n    @[] 0xa, 'unsubscribe'\n    @[] 0xb, 'unsuback'\n    @[] 0xc, 'pingreq'\n    @[] 0xd, 'pingresp'\n    @[] 0xe, 'disconnect'\n    @[] 0xf, 'auth'\n\n  const type_map = new Map()\n  for const [id, type] of entries ::\n    const cmd = id << 4\n    type_map.set(cmd, {type, cmd, id})\n\n  return @[]\n    type_map.get.bind(type_map)\n    Array.from @ type_map.values()\n\n","import {decode_varint} from './mqtt_varint.jsy'\nimport {mqtt_cmd_by_type} from './mqtt_cmds.jsy'\n\n\nexport function _mqtt_raw_pkt_decode_v(u8_ref, _pkt_ctx_) ::\n  const [u8] = u8_ref\n  const [len_body, len_vh] = decode_varint(u8, 1)\n\n  const len_pkt = len_body + len_vh\n  if u8.byteLength >= len_pkt ::\n    const b0 = u8[0], cmd = b0 & 0xf0, hdr = b0 & 0x0f\n    u8_ref[0] = u8.subarray(len_pkt)\n    return @{} __proto__: _pkt_ctx_\n      b0, cmd, hdr\n      type_obj: mqtt_cmd_by_type(cmd)\n      u8_body: 0 === len_body ? null\n        : u8.subarray(len_vh, len_pkt)\n\n\nexport function _mqtt_raw_pkt_dispatch(u8_pkt_dispatch) ::\n  return @\\ _pkt_ctx_={} ::\n    const l = [new Uint8Array(0)] // reuse array to prevent garbage collection churn on ephemeral ones\n    _pkt_ctx_._base_ = _pkt_ctx_\n\n    return @\\ u8_buf ::\n      l[0] = 0 === l[0].byteLength\n        ? u8_buf : _u8_join(l[0], u8_buf)\n\n      const res = []\n      while true ::\n        const u8_pkt = _mqtt_raw_pkt_decode_v(l, _pkt_ctx_)\n        if undefined !== u8_pkt ::\n          res.push @ u8_pkt_dispatch(u8_pkt)\n        else return res\n\n\nfunction _u8_join(a, b) ::\n  const alen = a.byteLength\n  const r = new Uint8Array(alen + b.byteLength)\n  r.set(a, 0)\n  r.set(b, alen)\n  return r\n\n","import { _mqtt_raw_pkt_dispatch } from './framing.jsy'\n\n\nexport const _mqtt_pkt_id_dispatch = disp_parser =>\n  _mqtt_raw_pkt_dispatch @\\ pkt ::\n    const fn_disp = disp_parser[pkt.type_obj.id]\n    return undefined !== fn_disp\n      ? fn_disp.call(disp_parser, pkt)\n      : disp_parser[0](pkt)\n\n\nexport const _mqtt_bind_encode = enc_by_type =>\n  @\\ mqtt_level ::\n    mqtt_level = +mqtt_level || mqtt_level.mqtt_level\n    return @\\ type, pkt =>\n      enc_by_type[type] @ mqtt_level, pkt\n\n\nexport function _bind_mqtt_session(mqtt_level, mqtt_decode_session, mqtt_encode_session) ::\n  mqtt_level = mqtt_level || 4\n  return @\\ _pkt_ctx_={mqtt_level} => @[]\n    mqtt_decode_session(_pkt_ctx_)\n    mqtt_encode_session(_pkt_ctx_)\n\n","import { mqtt_decode_ops_by_id } from './_decode_all.jsy'\nimport { mqtt_encode_by_type } from './_encode_all.jsy'\nimport @{}\n  _mqtt_pkt_id_dispatch,\n  _mqtt_bind_encode,\n  _bind_mqtt_session,\nfrom './_session_all.jsy'\n\nexport const mqtt_decode_session =\n  _mqtt_pkt_id_dispatch @\n    mqtt_decode_ops_by_id\n\nexport const mqtt_encode_session =\n  _mqtt_bind_encode @\n    mqtt_encode_by_type\n\nexport const mqtt_session_v4 =\n  _bind_mqtt_session @ 4,\n    mqtt_decode_session,\n    mqtt_encode_session,\n\nexport const mqtt_session_v5 =\n  _bind_mqtt_session @ 5,\n    mqtt_decode_session,\n    mqtt_encode_session,\n\nexport @{}\n  mqtt_session_v4 as mqtt_session,\n  mqtt_session_v4 as default,\n\n","import {mqtt_session} from '../session.jsy'\nimport {MQTTClient, _mqtt_web_api} from './core_web.jsy'\n\nexport default MQTTClient.with_api @\n  _mqtt_web_api(mqtt_session)\n\n","\nexport class MQTTClient ::\n  constructor(on_mqtt) ::\n    if 'function' === typeof on_mqtt ::\n      this._on_mqtt = on_mqtt\n\n  _on_mqtt(pkt_list) ::\n\n  auth(pkt) :: this._send('auth', pkt)\n  connect(pkt) :: this._send('connect', pkt)\n  disconnect(pkt) :: this._send('disconnect', pkt)\n  publish(pkt) :: this._send('publish', pkt)\n  subscribe(pkt) :: this._send('subscribe', pkt)\n  unsubscribe(pkt) :: this._send('unsubscribe', pkt)\n\n  static with_api(api) ::\n    class MQTTClient extends this ::\n    Object.assign @ MQTTClient.prototype, api\n    return MQTTClient\n\n","export {MQTTClient} from './core.jsy'\n\nexport function _mqtt_web_api(mqtt_session) ::\n  return @{}\n    async with_websock(websock) ::\n      if 'string' === typeof websock ::\n        websock = new WebSocket(websock, ['mqtt'])\n\n      const {readyState} = websock\n      if 1 !== readyState ::\n        if 0 !== readyState ::\n          throw new Error @ 'Invalid WebSocket readyState'\n\n        await new Promise @ y =>\n          websock.addEventListener @ 'open', y, {once: true}\n\n\n      const [mqtt_decode, mqtt_encode] =\n        mqtt_session()\n\n      this._send = @\\ type, pkt ::>\n        websock.send @\n          mqtt_encode(type, pkt)\n        return true\n\n      websock.onmessage = @\\: data ::>\n        const u8_buf = new Uint8Array @\n          data instanceof ArrayBuffer ? data\n            : await data.arrayBuffer()\n\n        this._on_mqtt @\n          mqtt_decode(u8_buf)\n\n      return this\n\n"],"names":["n","a","ni","vi_tuple","plural","prop_obj","prop_map","Array","[object Object]","this","r","step","buf","rdr","prop_entries","name","super","reason_map","u8","reserved","clean_start","will_flag","will_qos","will_retain","password","username","session_present","pkt","qos","retain","retain_handling","answers","err","payload","flags","mqtt_decode_pubrec","mqtt_decode_pubrel","mqtt_decode_pubcomp","topic_list","topic","opts","mqtt_decode_noop","Object","v","pack_u16","pack_u32","encode_varint","push","u8_buf","undefined","mqtt_type_writer","rope","i","_pool_","mqtt_pkt_writer_pool","connect_flags","wrt","connect","mqtt_level","_enc_connect_flags","connack","publish","puback","pubrec","pubrel","pubcomp","subscribe","suback","unsubscribe","unsuback","pingreq","pingresp","disconnect","auth","type_map","u8_ref","__proto__","b0","type_obj","u8_body","_pkt_ctx_","l","res","u8_pkt_dispatch","mqtt_decode_session","mqtt_encode_session","mqtt_decode_ops_by_id","_mqtt_raw_pkt_dispatch","mqtt_encode_by_type","enc_by_type","_bind_mqtt_session","MQTTClient","websock","y","mqtt_session","mqtt_encode","data","mqtt_decode"],"mappings":"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"}