{"version":3,"file":"node.mjs","sources":["../../code/mqtt_varint.jsy","../../code/mqtt_props.jsy","../../code/decode/_utils.jsy","../../code/decode/connect.jsy","../../code/decode/connack.jsy","../../code/decode/publish.jsy","../../code/decode/puback.jsy","../../code/decode/_pubrec_pubrel_pubcomp.jsy","../../code/decode/subscribe.jsy","../../code/decode/_suback_unsuback.jsy","../../code/decode/suback.jsy","../../code/decode/unsubscribe.jsy","../../code/decode/unsuback.jsy","../../code/decode/disconnect.jsy","../../code/decode/auth.jsy","../../code/_decode_all.jsy","../../code/encode/_pkt_writer.jsy","../../code/encode/_utils.jsy","../../code/encode/connect.jsy","../../code/encode/connack.jsy","../../code/encode/publish.jsy","../../code/encode/puback.jsy","../../code/encode/_pubrec_pubrel_pubcomp.jsy","../../code/encode/pubrec.jsy","../../code/encode/pubrel.jsy","../../code/encode/pubcomp.jsy","../../code/encode/subscribe.jsy","../../code/encode/_suback_unsuback.jsy","../../code/encode/suback.jsy","../../code/encode/unsubscribe.jsy","../../code/encode/unsuback.jsy","../../code/encode/pingreq.jsy","../../code/encode/pingresp.jsy","../../code/encode/disconnect.jsy","../../code/encode/auth.jsy","../../code/_encode_all.jsy","../../code/mqtt_cmds.jsy","../../code/framing.jsy","../../code/_session_all.jsy","../../code/session.jsy","../../code/client/core.jsy","../../code/client/core_node.jsy","../../code/client/node.jsy"],"sourcesContent":["export function encode_varint(n, a=[]) ::\n  do ::\n    const ni = n & 0x7f\n    n >>>= 7\n    a.push @ ni | (0===n ? 0 : 0x80)\n  while n > 0\n  return a\n\n\nexport function decode_varint_loop(u8, vi=0, vi_tuple=[]) ::\n  let shift = 0, n = (u8[vi] & 0x7f)\n  while 0x80 & u8[vi++] ::\n    n |= (u8[vi] & 0x7f) << (shift += 7)\n\n  vi_tuple[0] = n\n  vi_tuple[1] = vi\n  return vi_tuple\n\n\nexport function decode_varint(u8, vi=0, vi_tuple=[]) ::\n  // unrolled for a max of 4 chains\n  let n = (u8[vi] & 0x7f) <<  0\n  if 0x80 & u8[vi++] ::\n    n |= (u8[vi] & 0x7f) <<  7\n    if 0x80 & u8[vi++] ::\n      n |= (u8[vi] & 0x7f) << 14\n      if 0x80 & u8[vi++] ::\n        n |= (u8[vi] & 0x7f) << 21\n\n  vi_tuple[0] = n\n  vi_tuple[1] = vi\n  return vi_tuple\n\n","\nexport const [mqtt_props_by_id, mqtt_props_entries] = @!\n  const entries = @[]\n    @[] 0x01, 'u8',   'payload_format_indicator'\n    @[] 0x02, 'u32',  'message_expiry_interval', \n    @[] 0x03, 'utf8', 'content_type', \n    @[] 0x08, 'utf8', 'response_topic', \n    @[] 0x09, 'bin',  'correlation_data', \n    @[] 0x0B, 'vint', 'subscription_identifier', \n    @[] 0x11, 'u32',  'session_expiry_interval', \n    @[] 0x12, 'utf8', 'assigned_client_identifier', \n    @[] 0x13, 'u16',  'server_keep_alive', \n    @[] 0x15, 'utf8', 'authentication_method', \n    @[] 0x16, 'bin',  'authentication_data', \n    @[] 0x17, 'u8',   'request_problem_information', \n    @[] 0x18, 'u32',  'will_delay_interval', \n    @[] 0x19, 'u8',   'request_response_information', \n    @[] 0x1A, 'utf8', 'response_information', \n    @[] 0x1C, 'utf8', 'server_reference', \n    @[] 0x1F, 'utf8', 'reason_string', \n    @[] 0x21, 'u16',  'receive_maximum', \n    @[] 0x22, 'u16',  'topic_alias_maximum', \n    @[] 0x23, 'u16',  'topic_alias', \n    @[] 0x24, 'u8',   'maximum_qo_s', \n    @[] 0x25, 'u8',   'retain_available', \n    @[] 0x26, 'pair', 'user_properties', true\n    @[] 0x27, 'u32',  'maximum_packet_size', \n    @[] 0x28, 'u8',   'wildcard_subscription_available', \n    @[] 0x29, 'u8',   'subscription_identifiers_available', true\n    @[] 0x2A, 'u8',   'shared_subscription_available', \n\n\n  const prop_map = new Map()\n  for const [id, type, name, plural] of entries ::\n    const prop_obj = {id, type, name}\n    if plural :: prop_obj.plural = plural\n    prop_map.set(prop_obj.id, prop_obj)\n    prop_map.set(prop_obj.name, prop_obj)\n\n  return @[]\n    prop_map.get.bind(prop_map)\n    Array.from @ prop_map.values()\n","import {decode_varint} from '../mqtt_varint.jsy'\nimport {mqtt_props_by_id} from '../mqtt_props.jsy'\n\n\nexport class mqtt_type_reader ::\n  constructor(buf, idx=0) ::\n    this.buf = buf\n    this.step = (width, r) => @ r = idx, idx += width, r\n\n  has_more() ::\n    const {buf, step} = this\n    return buf.byteLength > step(0)\n\n  u8() ::\n    const {buf, step} = this\n    return buf[step(1)]\n\n  u16() ::\n    const {buf, step} = this\n    const i = step(2)\n    return (buf[i]<<8) | buf[i+1]\n\n  u32() ::\n    const {buf, step} = this\n    const i = step(4)\n    return (buf[i]<<24) | (buf[i+1]<<16) | (buf[i+2]<<8) | buf[i+3]\n\n  vint() ::\n    const {buf, step} = this\n    const [n, vi] = decode_varint(buf, step(0))\n    step(vi)\n    return n\n\n  bin() ::\n    const {buf, step} = this\n    const i = step(2)\n    const len = (buf[i]<<8) | buf[i+1]\n    const i0 = step(len)\n    return buf.subarray(i0, i0+len)\n\n  utf8() :: return new TextDecoder('utf-8').decode @ this.bin()\n  pair() :: return @[] this.utf8(), this.utf8()\n\n  u8_flags(FlagsType) ::\n    const {buf, step} = this\n    return new FlagsType(buf[step(1)])\n\n  u8_reason(fn_reason) ::\n    const {buf, step} = this\n    return fn_reason @ buf[step(1)]\n\n  flush() ::\n    const {buf, step} = this\n    this.step = this.buf = null\n    return buf.subarray(step(0))\n\n  props() ::\n    const {buf, step} = this\n\n    const [len, vi] = decode_varint(buf, step(0))\n    const end_part = vi + len\n    step(end_part)\n    if 0 === len ::\n      return null\n\n    const prop_entries = @[]\n    const rdr = mqtt_reader @\n      buf.subarray(vi, end_part)\n\n    while rdr.has_more() ::\n      const {name, type} = mqtt_props_by_id @ rdr.u8()\n      const value = rdr[type]()\n      prop_entries.push @# name, value\n\n    return prop_entries\n\n\n\nclass U8_Reason extends Number ::\n  constructor(u8, reason) ::\n    super(u8)\n    this.reason = reason\n\nexport function bind_reason_lookup(reason_entries) ::\n  const reason_map = new Map()\n  for const [u8, reason] of reason_entries ::\n    reason_map.set @ u8, new U8_Reason(u8, reason)\n\n  return reason_map.get.bind(reason_map)\n\n","import {mqtt_type_reader} from './_utils.jsy'\n\nclass _connect_flags_ extends Number ::\n  get reserved() :: return this & 0x01 !== 0\n  get clean_start() :: return this & 0x02 !== 0\n  get will_flag() :: return this & 0x04 !== 0\n  get will_qos() :: return (this >>> 3) & 0x3\n  get will_retain() :: return this & 0x20 !== 0\n  get password() :: return this & 0x40 !== 0\n  get username() :: return this & 0x80 !== 0\n\n\nexport function mqtt_decode_connect(pkt) ::\n  const rdr = new mqtt_type_reader(pkt.u8_body, 0)\n  if 'MQTT' !== rdr.utf8() ::\n    throw new Error @ 'Invalid mqtt_connect packet'\n\n  pkt._base_.mqtt_level = pkt.mqtt_level = rdr.u8()\n\n  const flags = pkt.connect_flags =\n    rdr.u8_flags(_connect_flags_)\n\n  pkt.keep_alive = rdr.u16()\n\n  if 5 <= pkt.mqtt_level ::\n    pkt.props = rdr.props()\n\n\n\n  const payload = pkt.payload = {}\n  payload.client_id = rdr.utf8()\n  if flags.will_flag ::\n    if 5 <= pkt.mqtt_level ::\n      payload.will_properties = rdr.props()\n\n    payload.will_topic = rdr.utf8()\n    payload.will_payload = rdr.bin()\n\n  if flags.username ::\n    payload.username = rdr.utf8()\n\n  if flags.password ::\n    payload.password = rdr.bin()\n  return pkt\n\n","import {mqtt_type_reader, bind_reason_lookup} from './_utils.jsy'\n\nclass _connack_flags_ extends Number ::\n  get session_present() :: return this & 0x01 !== 0\n\nexport const _connack_reason_ = bind_reason_lookup @#\n  // MQTT 3.1.1\n  @[] 0x00, 'Success'\n  @[] 0x01, 'Connection refused, unacceptable protocol version'\n  @[] 0x02, 'Connection refused, identifier rejected'\n  @[] 0x03, 'Connection refused, server unavailable'\n  @[] 0x04, 'Connection refused, bad user name or password'\n  @[] 0x05, 'Connection refused, not authorized'\n\n  // MQTT 5.0\n  @[] 0x81, 'Malformed Packet'\n  @[] 0x82, 'Protocol Error'\n  @[] 0x83, 'Implementation specific error'\n  @[] 0x84, 'Unsupported Protocol Version'\n  @[] 0x85, 'Client Identifier not valid'\n  @[] 0x86, 'Bad User Name or Password'\n  @[] 0x87, 'Not authorized'\n  @[] 0x88, 'Server unavailable'\n  @[] 0x89, 'Server busy'\n  @[] 0x8A, 'Banned'\n  @[] 0x8C, 'Bad authentication method'\n  @[] 0x90, 'Topic Name invalid'\n  @[] 0x95, 'Packet too large'\n  @[] 0x97, 'Quota exceeded'\n  @[] 0x99, 'Payload format invalid'\n  @[] 0x9A, 'Retain not supported'\n  @[] 0x9B, 'QoS not supported'\n  @[] 0x9C, 'Use another server'\n  @[] 0x9D, 'Server moved'\n  @[] 0x9F, 'Connection rate exceeded'\n\n\nexport function mqtt_decode_connack(pkt) ::\n  const rdr = new mqtt_type_reader(pkt.u8_body, 0)\n\n  const flags = pkt.connect_flags =\n    rdr.u8_flags(_connack_flags_)\n\n  pkt.reason = rdr.u8_reason(_connack_reason_)\n  if 5 <= pkt.mqtt_level ::\n    pkt.props = rdr.props()\n  return pkt\n\n","import {mqtt_type_reader} from './_utils.jsy'\n\nexport function mqtt_decode_publish(pkt) ::\n  const {hdr} = pkt\n  pkt.dup = Boolean(hdr & 0x8)\n  pkt.retain = Boolean(hdr & 0x1)\n  const qos = pkt.qos = (hdr>>1) & 0x3\n\n  const rdr = new mqtt_type_reader(pkt.u8_body, 0)\n  pkt.topic = rdr.utf8()\n  if 0 !== qos ::\n    pkt.pkt_id = rdr.u16()\n\n  if 5 <= pkt.mqtt_level ::\n    pkt.props = rdr.props()\n    pkt.payload = rdr.flush()\n  else ::\n    pkt.payload = rdr.flush()\n\n  return pkt\n\n","import {mqtt_type_reader, bind_reason_lookup} from './_utils.jsy'\n\nexport const _puback_reason_ = bind_reason_lookup @#\n  @[] 0x00, 'Success'\n\n  // MQTT 5.0\n  @[] 0x10, 'No matching subscribers'\n  @[] 0x80, 'Unspecified error'\n  @[] 0x83, 'Implementation specific error'\n  @[] 0x87, 'Not authorized'\n  @[] 0x90, 'Topic Name invalid'\n  @[] 0x91, 'Packet identifier in use'\n  @[] 0x97, 'Quota exceeded'\n  @[] 0x99, 'Payload format invalid'\n\n\nexport function mqtt_decode_puback(pkt) ::\n  const rdr = new mqtt_type_reader(pkt.u8_body, 0)\n\n  pkt.pkt_id = rdr.u16()\n  if 5 <= pkt.mqtt_level ::\n    pkt.reason = rdr.u8_reason(_puback_reason_)\n    pkt.props = rdr.props()\n\n  return pkt\n\n","import {mqtt_type_reader, bind_reason_lookup} from './_utils.jsy'\n\nexport const _pubxxx_reason_ = bind_reason_lookup @#\n  @[] 0x00, 'Success'\n  @[] 0x92, 'Packet Identifier not found'\n\n\nexport function _mqtt_decode_pubxxx(pkt) ::\n  const rdr = new mqtt_type_reader(pkt.u8_body, 0)\n\n  pkt.pkt_id = rdr.u16()\n  pkt.reason = rdr.u8_reason(_pubxxx_reason_)\n  if 5 <= pkt.mqtt_level ::\n    pkt.props = rdr.props()\n  return pkt\n\n","import {mqtt_type_reader} from './_utils.jsy'\n\nclass _subscription_options_ extends Number ::\n  get qos() :: return this & 0x3\n  get retain() :: return this & 0x4 !== 0\n  get retain_handling() :: return (this >> 2) & 0x3\n\nexport function mqtt_decode_subscribe(pkt) ::\n  const rdr = new mqtt_type_reader(pkt.u8_body, 0)\n\n  pkt.pkt_id = rdr.u16()\n  if 5 <= pkt.mqtt_level ::\n    pkt.props = rdr.props()\n\n  const topic_list = pkt.topics = []\n  while rdr.has_more() ::\n    topic_list.push @:\n      topic: rdr.utf8()\n      opts: rdr.u8_flags(_subscription_options_)\n\n  return pkt\n\n","import {mqtt_type_reader} from './_utils.jsy'\n\nexport function _mqtt_decode_suback(pkt, _ack_reason_) ::\n  const rdr = new mqtt_type_reader(pkt.u8_body, 0)\n\n  pkt.pkt_id = rdr.u16()\n  if 5 <= pkt.mqtt_level ::\n    pkt.props = rdr.props()\n\n  const answers = pkt.answers = []\n  while rdr.has_more() ::\n    answers.push @\n      rdr.u8_reason(_ack_reason_)\n\n  return pkt\n\n","import {bind_reason_lookup} from './_utils.jsy'\nimport {_mqtt_decode_suback} from './_suback_unsuback.jsy'\n\nexport const _suback_reason_ = bind_reason_lookup @#\n  // MQTT 3.1.1\n  @[] 0x00, 'Granted QoS 0'\n  @[] 0x01, 'Granted QoS 1'\n  @[] 0x02, 'Granted QoS 2'\n\n  // MQTT 5.0\n  @[] 0x80, 'Unspecified error'\n  @[] 0x83, 'Implementation specific error'\n  @[] 0x87, 'Not authorized'\n  @[] 0x8F, 'Topic Filter invalid'\n  @[] 0x91, 'Packet Identifier in use'\n  @[] 0x97, 'Quota exceeded'\n  @[] 0x9E, 'Shared Subscriptions not supported'\n  @[] 0xA1, 'Subscription Identifiers not supported'\n  @[] 0xA2, 'Wildcard Subscriptions not supported'\n\n\nexport function mqtt_decode_suback(pkt) ::\n  return _mqtt_decode_suback @\n    pkt, _suback_reason_\n\n","import {mqtt_type_reader} from './_utils.jsy'\n\nexport function mqtt_decode_unsubscribe(pkt) ::\n  const rdr = new mqtt_type_reader(pkt.u8_body, 0)\n\n  pkt.pkt_id = rdr.u16()\n  if 5 <= pkt.mqtt_level ::\n    pkt.props = rdr.props()\n\n  const topic_list = pkt.topics = []\n  while rdr.has_more() ::\n    topic_list.push @ rdr.utf8()\n\n  return pkt\n\n","import {bind_reason_lookup} from './_utils.jsy'\nimport {_mqtt_decode_suback} from './_suback_unsuback.jsy'\n\nexport const _unsuback_reason_ = bind_reason_lookup @#\n  @[] 0x00, 'Success'\n  @[] 0x11, 'No subscription existed'\n  @[] 0x80, 'Unspecified error'\n  @[] 0x83, 'Implementation specific error'\n  @[] 0x87, 'Not authorized'\n  @[] 0x8F, 'Topic Filter invalid'\n  @[] 0x91, 'Packet Identifier in use'\n\nexport function mqtt_decode_unsuback(pkt) ::\n  return _mqtt_decode_suback @\n    pkt, _unsuback_reason_\n\n","import {mqtt_type_reader, bind_reason_lookup} from './_utils.jsy'\n\nexport const _disconnect_reason_ = bind_reason_lookup @#\n  // MQTT 5.0\n  @[] 0x00, 'Normal disconnection'\n  @[] 0x04, 'Disconnect with Will Message'\n  @[] 0x80, 'Unspecified error'\n  @[] 0x81, 'Malformed Packet'\n  @[] 0x82, 'Protocol Error'\n  @[] 0x83, 'Implementation specific error'\n  @[] 0x87, 'Not authorized'\n  @[] 0x89, 'Server busy'\n  @[] 0x8B, 'Server shutting down'\n  @[] 0x8D, 'Keep Alive timeout'\n  @[] 0x8E, 'Session taken over'\n  @[] 0x8F, 'Topic Filter invalid'\n  @[] 0x90, 'Topic Name invalid'\n  @[] 0x93, 'Receive Maximum exceeded'\n  @[] 0x94, 'Topic Alias invalid'\n  @[] 0x95, 'Packet too large'\n  @[] 0x96, 'Message rate too high'\n  @[] 0x97, 'Quota exceeded'\n  @[] 0x98, 'Administrative action'\n  @[] 0x99, 'Payload format invalid'\n  @[] 0x9A, 'Retain not supported'\n  @[] 0x9B, 'QoS not supported'\n  @[] 0x9C, 'Use another server'\n  @[] 0x9D, 'Server moved'\n  @[] 0x9E, 'Shared Subscriptions not supported'\n  @[] 0x9F, 'Connection rate exceeded'\n  @[] 0xA0, 'Maximum connect time'\n  @[] 0xA1, 'Subscription Identifiers not supported'\n  @[] 0xA2, 'Wildcard Subscriptions not supported'\n\n\nexport function mqtt_decode_disconnect(pkt) ::\n  if 5 <= pkt.mqtt_level ::\n    const rdr = new mqtt_type_reader(pkt.u8_body, 0)\n    pkt.reason = rdr.u8_reason(_disconnect_reason_)\n    pkt.props = rdr.props()\n  return pkt\n\n","import {mqtt_type_reader, bind_reason_lookup} from './_utils.jsy'\n\nexport const _auth_reason_ = bind_reason_lookup @#\n  // MQTT 5.0\n  @[] 0x00, 'Success'\n  @[] 0x18, 'Continue authentication'\n  @[] 0x19, 'Re-authenticate'\n\nexport function mqtt_decode_auth(pkt) ::\n  if 5 <= pkt.mqtt_level ::\n    const rdr = new mqtt_type_reader(pkt.u8_body, 0)\n    pkt.reason = rdr.u8_reason(_auth_reason_)\n    pkt.props = rdr.props()\n  return pkt\n\n","import {mqtt_decode_connect} from './decode/connect.jsy'\nimport {mqtt_decode_connack} from './decode/connack.jsy'\nimport {mqtt_decode_publish} from './decode/publish.jsy'\nimport {mqtt_decode_puback} from './decode/puback.jsy'\nimport {mqtt_decode_pubrec} from './decode/pubrec.jsy'\nimport {mqtt_decode_pubrel} from './decode/pubrel.jsy'\nimport {mqtt_decode_pubcomp} from './decode/pubcomp.jsy'\nimport {mqtt_decode_subscribe} from './decode/subscribe.jsy'\nimport {mqtt_decode_suback} from './decode/suback.jsy'\nimport {mqtt_decode_unsubscribe} from './decode/unsubscribe.jsy'\nimport {mqtt_decode_unsuback} from './decode/unsuback.jsy'\nimport {mqtt_decode_disconnect} from './decode/disconnect.jsy'\nimport {mqtt_decode_auth} from './decode/auth.jsy'\n\nexport * from './decode/_utils.jsy'\n\nfunction mqtt_dnu_decode(pkt) ::\n  const err = new Error @ 'MQTT packet not understood'\n  err.pkt = pkt\n  throw err\n\nconst mqtt_decode_noop = pkt => pkt\n\n\nexport const mqtt_decode_ops_by_id = @[]\n  mqtt_dnu_decode\n  mqtt_decode_connect\n  mqtt_decode_connack\n  mqtt_decode_publish\n  mqtt_decode_puback\n  mqtt_decode_pubrec\n  mqtt_decode_pubrel\n  mqtt_decode_pubcomp\n  mqtt_decode_subscribe\n  mqtt_decode_suback\n  mqtt_decode_unsubscribe\n  mqtt_decode_unsuback\n  mqtt_decode_noop // mqtt_decode_pingreq\n  mqtt_decode_noop // mqtt_decode_pingresp\n  mqtt_decode_disconnect\n  mqtt_decode_auth\n\n\nexport @{}\n  mqtt_dnu_decode,\n  mqtt_decode_connect,\n  mqtt_decode_connack,\n  mqtt_decode_publish,\n  mqtt_decode_puback,\n  mqtt_decode_pubrec,\n  mqtt_decode_pubrel,\n  mqtt_decode_pubcomp,\n  mqtt_decode_subscribe,\n  mqtt_decode_suback,\n  mqtt_decode_unsubscribe,\n  mqtt_decode_unsuback,\n  mqtt_decode_noop as mqtt_decode_pingreq,\n  mqtt_decode_noop as mqtt_decode_pingresp,\n  mqtt_decode_disconnect,\n  mqtt_decode_auth,\n  mqtt_decode_noop\n\n","import {encode_varint} from '../mqtt_varint.jsy'\n\nexport function mqtt_pkt_writer_pool() ::\n  const _pool_ = []\n  return @=> 0 === _pool_.length\n      ? mqtt_pkt_writer(_pool_)\n      : _pool_.pop()\n\nexport function mqtt_pkt_writer(_pool_) ::\n  let self, n=0, rope=[]\n  return self = @{}\n    push(u8) ::\n      #IF DEBUG\n        u8 = new Uint8Array(u8)\n\n      rope.push(u8)\n      n += u8.length\n\n    as_pkt(hdr) ::\n      const pkt = _mqtt_pkt_rope(hdr, n, rope)\n      n=0; rope=[]\n      if undefined !== _pool_ ::\n        _pool_.push(self)\n      return pkt\n\nexport function _mqtt_pkt_rope(hdr, n, rope) ::\n  const header = encode_varint(n, [hdr])\n  let i = header.length\n\n  const pkt = new Uint8Array(n + i)\n  pkt.set(header, 0)\n  for const vec of rope ::\n    pkt.set(vec, i)\n    i += vec.length\n  return pkt\n\n","import {encode_varint} from '../mqtt_varint.jsy'\n//import {mqtt_props_by_id} from '../mqtt_props.jsy'\nimport {mqtt_pkt_writer_pool} from './_pkt_writer.jsy'\n\nexport * from './_pkt_writer.jsy'\n\nconst pack_utf8 = v => new TextEncoder('utf-8').encode(v)\nconst pack_u16 = v => @[] (v>>>8) & 0xff, v & 0xff\nconst pack_u32 = v => @[] (v>>>24) & 0xff, (v>>>16) & 0xff, (v>>>8) & 0xff, v & 0xff\n\nexport class mqtt_type_writer ::\n  constructor() ::\n    Object.assign @ this, this._pkt_writer()\n\n  u8(v) :: this.push @# v & 0xff\n  u16(v) :: this.push @ pack_u16(v)\n  u32(v) :: this.push @ pack_u32(v)\n  vint(v) :: this.push @ encode_varint(v)\n\n  _u16_bin(u8_buf) ::\n    const {push} = this\n    push @ pack_u16 @ u8_buf.byteLength\n    push @ u8_buf\n\n  flush(buf) ::\n    this.push @\n      'string' === typeof buf\n        ? pack_utf8(buf) : buf\n\n    this.push = false\n\n  bin(u8_buf) ::\n    if 'string' === typeof u8_buf ::\n      return this.utf8(u8_buf)\n\n    if u8_buf.length !== u8_buf.byteLength ::\n      u8_buf = new Uint8Array(u8_buf)\n    this._u16_bin(u8_buf)\n\n  utf8(v) :: this._u16_bin @\n    new TextEncoder('utf-8').encode(v)\n\n  pair(k,v) ::\n    this.utf8(k)\n    this.utf8(v)\n\n  u8_flags(v, enc_flags) ::\n    if undefined !== v && isNaN(+v) ::\n      v = enc_flags(v, 0)\n    v |= 0\n    this.push @# v\n    return v\n\n  u8_reason(v) :: this.push @# v | 0\n\n  props() :: throw \"TODO\"\n\nmqtt_type_writer.prototype._pkt_writer = \n  mqtt_pkt_writer_pool()\n","import {mqtt_type_writer} from './_utils.jsy'\n\nconst _c_mqtt_proto = new Uint8Array @#\n  0, 4, 0x4d, 0x51, 0x54, 0x54\n\nexport function mqtt_encode_connect(mqtt_level, pkt) ::\n  const wrt = new mqtt_type_writer()\n\n  wrt.push(_c_mqtt_proto)\n  wrt.u8 @ mqtt_level\n  const flags = wrt.u8_flags @\n    pkt.connect_flags\n    _enc_connect_flags\n\n  wrt.u16(pkt.keep_alive)\n\n  if 5 <= mqtt_level ::\n    wrt.props(pkt.props)\n\n\n  const {payload} = pkt\n  wrt.utf8 @ payload.client_id\n  if flags & 0x04 :: // .will_flag\n    if 5 <= mqtt_level ::\n      wrt.props @ payload.will_properties\n\n    wrt.utf8 @ payload.will_topic\n    wrt.bin @ payload.will_payload\n\n  if flags & 0x80 :: // .username\n    wrt.utf8 @ payload.username\n\n  if flags & 0x40 :: // .password\n    wrt.bin @ payload.password\n\n  return wrt.as_pkt(0x10)\n\nconst _enc_connect_flags = flags => 0\n    | @ flags.reserved ? 0x01 : 0\n    | @ (flags.will_qos & 0x3) << 3\n    | @ flags.clean_start ? 0x02 : 0\n    | @ flags.will_flag ? 0x04 : 0\n    | @ flags.will_retain ? 0x20 : 0\n    | @ flags.password ? 0x40 : 0\n    | @ flags.username ? 0x80 : 0\n","import {mqtt_type_writer} from './_utils.jsy'\n\nexport function mqtt_encode_connack(mqtt_level, pkt) ::\n  const wrt = new mqtt_type_writer()\n\n  const {connect_flags} = pkt\n  wrt.u8_flags @ pkt.connect_flags, _enc_flags_connack\n\n  if 5 <= mqtt_level ::\n    wrt.u8_reason @ pkt.reason\n    wrt.props @ pkt.props\n\n  else ::\n    wrt.u8_reason @ pkt.return_code || pkt.reason\n\n  return wrt.as_pkt(0x20)\n\nconst _enc_flags_connack = connect_flags =>\n  connect_flags.session_present ? 1 : 0\n\n","import {mqtt_type_writer} from './_utils.jsy'\n\nexport function mqtt_encode_publish(mqtt_level, pkt) ::\n  const qos = (pkt.qos & 0x3) << 1\n  const wrt = new mqtt_type_writer()\n\n  wrt.utf8(pkt.topic)\n  if 0 !== qos ::\n    wrt.u16(pkt.pkt_id)\n\n  if 5 <= mqtt_level ::\n    wrt.props(pkt.props)\n    wrt.flush(pkt.payload)\n  else ::\n    wrt.flush(pkt.payload)\n\n  return wrt.as_pkt @\n    0x30 | qos | (pkt.dup ? 0x8 : 0) | (pkt.retain ? 0x1 : 0)\n\n","import {mqtt_type_writer} from './_utils.jsy'\n\nexport function mqtt_encode_puback(mqtt_level, pkt) ::\n  const wrt = new mqtt_type_writer()\n\n  wrt.u16(pkt.pkt_id)\n  if 5 <= mqtt_level ::\n    wrt.u8_reason(pkt.reason)\n    wrt.props(pkt.props)\n\n  return wrt.as_pkt(0x40)\n\n\n","import {mqtt_type_writer} from './_utils.jsy'\n\n\nexport function _mqtt_encode_pubxxx(hdr, mqtt_level, pkt) ::\n  const wrt = new mqtt_type_writer()\n\n  wrt.u16(pkt.pkt_id)\n  if 5 <= mqtt_level ::\n    wrt.props(pkt.props)\n    wrt.u8_reason @ pkt.reason\n\n  else ::\n    wrt.u8_reason @ pkt.return_code || pkt.reason\n\n  return wrt.as_pkt(hdr)\n\n","import {_mqtt_encode_pubxxx} from './_pubrec_pubrel_pubcomp.jsy'\n\nexport function mqtt_encode_pubrec(mqtt_level, pkt) ::\n  return _mqtt_encode_pubxxx @ 0x50, mqtt_level, pkt\n\n","import {_mqtt_encode_pubxxx} from './_pubrec_pubrel_pubcomp.jsy'\n\nexport function mqtt_encode_pubrel(mqtt_level, pkt) ::\n  return _mqtt_encode_pubxxx @ 0x62, mqtt_level, pkt\n","import {_mqtt_encode_pubxxx} from './_pubrec_pubrel_pubcomp.jsy'\n\nexport function mqtt_encode_pubcomp(mqtt_level, pkt) ::\n  return _mqtt_encode_pubxxx @ 0x70, mqtt_level, pkt\n\n","import {mqtt_type_writer} from './_utils.jsy'\n\nexport function mqtt_encode_subscribe(mqtt_level, pkt) ::\n  const wrt = new mqtt_type_writer()\n\n  wrt.u16(pkt.pkt_id)\n  if 5 <= pkt.mqtt_level ::\n    wrt.props(pkt.props)\n\n  for const each of pkt.topics ::\n    if 'string' === typeof each ::\n      wrt.utf8(each)\n      wrt.u8(0)\n\n    else if Array.isArray(each) ::\n      wrt.utf8(each[0])\n      wrt.u8_flags(each[1], _enc_subscribe_flags)\n\n    else ::\n      wrt.utf8(each.topic)\n      wrt.u8_flags(each.opts, _enc_subscribe_flags)\n\n  return wrt.as_pkt(0x82)\n\nconst _enc_subscribe_flags = opts => 0\n    | @ opts.qos & 0x3\n    | @ opts.retain ? 0x4 : 0\n    | @ (opts.retain_handling & 0x3) << 2  \n\n","import {mqtt_type_writer} from './_utils.jsy'\n\nexport function _mqtt_encode_suback(hdr, mqtt_level, pkt, key_answers) ::\n  const wrt = new mqtt_type_writer()\n\n  wrt.u16(pkt.pkt_id)\n  if 5 <= pkt.mqtt_level ::\n    wrt.props @ pkt.props\n\n  for const ans of pkt[key_answers] ::\n    wrt.u8_reason(ans)\n\n  return wrt.as_pkt(hdr)\n\n","import {_mqtt_encode_suback} from './_suback_unsuback.jsy'\n\nexport function mqtt_encode_suback(mqtt_level, pkt) ::\n  return _mqtt_encode_suback @\n    0x90, mqtt_level, pkt\n\n","import {mqtt_type_writer} from './_utils.jsy'\n\nexport function mqtt_encode_unsubscribe(mqtt_level, pkt) ::\n  const wrt = new mqtt_type_writer()\n\n  wrt.u16(pkt.pkt_id)\n  if 5 <= pkt.mqtt_level ::\n    wrt.props(pkt.props)\n\n  for const topic of pkt.topics ::\n    wrt.utf8(topic)\n\n  return wrt.as_pkt(0xa2)\n\n","import {_mqtt_encode_suback} from './_suback_unsuback.jsy'\n\nexport function mqtt_encode_unsuback(mqtt_level, pkt) ::\n  return _mqtt_encode_suback @\n    0xb0, mqtt_level, pkt\n\n","export const mqtt_encode_pingreq = @=>\n  new Uint8Array @# 0xc0, 0\n","export const mqtt_encode_pingresp = @=>\n  new Uint8Array @# 0xd0, 0\n","import {mqtt_type_writer} from './_utils.jsy'\n\nexport function mqtt_encode_disconnect(mqtt_level, pkt) ::\n  const wrt = new mqtt_type_writer()\n\n  if 5 <= mqtt_level ::\n    wrt.u8_reason @ pkt.reason\n    wrt.props @ pkt.props\n\n  return wrt.as_pkt(0xe0)\n\n","import {mqtt_type_writer} from './_utils.jsy'\n\nexport function mqtt_encode_auth(mqtt_level, pkt) ::\n  if 5 > mqtt_level ::\n    throw new Error @ 'Auth packets are only available after MQTT 5.x'\n\n  const wrt = new mqtt_type_writer()\n\n  wrt.u8_reason(pkt.reason)\n  wrt.props(pkt.props)\n\n  return wrt.as_pkt(0xf0)\n\n","import {mqtt_encode_connect} from './encode/connect.jsy'\nimport {mqtt_encode_connack} from './encode/connack.jsy'\nimport {mqtt_encode_publish} from './encode/publish.jsy'\nimport {mqtt_encode_puback} from './encode/puback.jsy'\nimport {mqtt_encode_pubrec} from './encode/pubrec.jsy'\nimport {mqtt_encode_pubrel} from './encode/pubrel.jsy'\nimport {mqtt_encode_pubcomp} from './encode/pubcomp.jsy'\nimport {mqtt_encode_subscribe} from './encode/subscribe.jsy'\nimport {mqtt_encode_suback} from './encode/suback.jsy'\nimport {mqtt_encode_unsubscribe} from './encode/unsubscribe.jsy'\nimport {mqtt_encode_unsuback} from './encode/unsuback.jsy'\nimport {mqtt_encode_pingreq} from './encode/pingreq.jsy'\nimport {mqtt_encode_pingresp} from './encode/pingresp.jsy'\nimport {mqtt_encode_disconnect} from './encode/disconnect.jsy'\nimport {mqtt_encode_auth} from './encode/auth.jsy'\n\nexport * from './encode/_utils.jsy'\n\nexport const mqtt_encode_by_type = @{}\n  connect: mqtt_encode_connect\n  connack: mqtt_encode_connack\n  publish: mqtt_encode_publish\n  puback: mqtt_encode_puback\n  pubrec: mqtt_encode_pubrec\n  pubrel: mqtt_encode_pubrel\n  pubcomp: mqtt_encode_pubcomp\n  subscribe: mqtt_encode_subscribe\n  suback: mqtt_encode_suback\n  unsubscribe: mqtt_encode_unsubscribe\n  unsuback: mqtt_encode_unsuback\n  pingreq: mqtt_encode_pingreq\n  pingresp: mqtt_encode_pingresp\n  disconnect: mqtt_encode_disconnect\n  auth: mqtt_encode_auth\n\n\nexport @{}\n  mqtt_encode_connect,\n  mqtt_encode_connack,\n  mqtt_encode_publish,\n  mqtt_encode_puback,\n  mqtt_encode_pubrec,\n  mqtt_encode_pubrel,\n  mqtt_encode_pubcomp,\n  mqtt_encode_subscribe,\n  mqtt_encode_suback,\n  mqtt_encode_unsubscribe,\n  mqtt_encode_unsuback,\n  mqtt_encode_pingreq,\n  mqtt_encode_pingresp,\n  mqtt_encode_disconnect,\n  mqtt_encode_auth,\n\n","\nexport const [mqtt_cmd_by_type, mqtt_type_entries] = @!\n\n  const entries = @[]\n    @[] 0x0, 'reserved'\n    @[] 0x1, 'connect'\n    @[] 0x2, 'connack'\n    @[] 0x3, 'publish'\n    @[] 0x4, 'puback'\n    @[] 0x5, 'pubrec'\n    @[] 0x6, 'pubrel'\n    @[] 0x7, 'pubcomp'\n    @[] 0x8, 'subscribe'\n    @[] 0x9, 'suback'\n    @[] 0xa, 'unsubscribe'\n    @[] 0xb, 'unsuback'\n    @[] 0xc, 'pingreq'\n    @[] 0xd, 'pingresp'\n    @[] 0xe, 'disconnect'\n    @[] 0xf, 'auth'\n\n  const type_map = new Map()\n  for const [id, type] of entries ::\n    const cmd = id << 4\n    type_map.set(cmd, {type, cmd, id})\n\n  return @[]\n    type_map.get.bind(type_map)\n    Array.from @ type_map.values()\n\n","import {decode_varint} from './mqtt_varint.jsy'\nimport {mqtt_cmd_by_type} from './mqtt_cmds.jsy'\n\n\nexport function _mqtt_raw_pkt_decode_v(u8_ref, _pkt_ctx_) ::\n  const [u8] = u8_ref\n  const [len_body, len_vh] = decode_varint(u8, 1)\n\n  const len_pkt = len_body + len_vh\n  if u8.byteLength >= len_pkt ::\n    const b0 = u8[0], cmd = b0 & 0xf0\n    u8_ref[0] = u8.subarray(len_pkt)\n    return @{} __proto__: _pkt_ctx_\n      b0, cmd, id: b0>>>4, hdr: b0 & 0x0f\n      type_obj: mqtt_cmd_by_type(cmd)\n      u8_body: 0 === len_body ? null\n        : u8.subarray(len_vh, len_pkt)\n\n\nexport function _mqtt_raw_pkt_dispatch(u8_pkt_dispatch) ::\n  return @\\ _pkt_ctx_={} ::\n    const l = [new Uint8Array(0)] // reuse array to prevent garbage collection churn on ephemeral ones\n    _pkt_ctx_._base_ = _pkt_ctx_\n\n    return @\\ u8_buf ::\n      l[0] = 0 === l[0].byteLength\n        ? u8_buf : _u8_join(l[0], u8_buf)\n\n      const res = []\n      while true ::\n        const u8_pkt = _mqtt_raw_pkt_decode_v(l, _pkt_ctx_)\n        if undefined !== u8_pkt ::\n          res.push @ u8_pkt_dispatch(u8_pkt)\n        else return res\n\n\nfunction _u8_join(a, b) ::\n  const alen = a.byteLength\n  const r = new Uint8Array(alen + b.byteLength)\n  r.set(a, 0)\n  r.set(b, alen)\n  return r\n\n","import { _mqtt_raw_pkt_dispatch } from './framing.jsy'\n\n\nexport const _mqtt_pkt_id_dispatch = disp_parser =>\n  _mqtt_raw_pkt_dispatch @\\ pkt ::\n    const fn_disp = disp_parser[pkt.type_obj.id]\n    return undefined !== fn_disp\n      ? fn_disp.call(disp_parser, pkt)\n      : disp_parser[0](pkt)\n\n\nexport const _mqtt_bind_encode = enc_by_type =>\n  @\\ mqtt_level ::\n    mqtt_level = +mqtt_level || mqtt_level.mqtt_level\n    return @\\ type, pkt =>\n      enc_by_type[type] @ mqtt_level, pkt\n\n\nexport function _bind_mqtt_session(mqtt_level, mqtt_decode_session, mqtt_encode_session) ::\n  mqtt_level = mqtt_level || 4\n  return @\\ _pkt_ctx_={mqtt_level} => @[]\n    mqtt_decode_session(_pkt_ctx_)\n    mqtt_encode_session(_pkt_ctx_)\n\n","import { mqtt_decode_ops_by_id } from './_decode_all.jsy'\nimport { mqtt_encode_by_type } from './_encode_all.jsy'\nimport @{}\n  _mqtt_pkt_id_dispatch,\n  _mqtt_bind_encode,\n  _bind_mqtt_session,\nfrom './_session_all.jsy'\n\nexport const mqtt_decode_session =\n  _mqtt_pkt_id_dispatch @\n    mqtt_decode_ops_by_id\n\nexport const mqtt_encode_session =\n  _mqtt_bind_encode @\n    mqtt_encode_by_type\n\nexport const mqtt_session_v4 =\n  _bind_mqtt_session @ 4,\n    mqtt_decode_session,\n    mqtt_encode_session,\n\nexport const mqtt_session_v5 =\n  _bind_mqtt_session @ 5,\n    mqtt_decode_session,\n    mqtt_encode_session,\n\nexport @{}\n  mqtt_session_v4 as mqtt_session,\n  mqtt_session_v4 as default,\n\n","\nexport class MQTTClient ::\n  constructor(target) ::\n    this._conn_ = this._transport(this)\n    this._disp_ = this._dispatch(this, target)\n\n  /* async _send(type, pkt) -- provided by _transport */\n  /* _on_mqtt(pkt_list, self) -- provided by _dispatch */\n\n  auth(pkt) :: return this._disp_send('auth', pkt, 'auth')\n  connect(pkt) :: return this._disp_send('connect', pkt, 'connack')\n\n  disconnect(pkt) :: return this._send('disconnect', pkt)\n  publish(pkt) ::\n    return pkt.qos > 0 \n      ? this._disp_send('publish', pkt, pkt)\n      : this._send('publish', pkt)\n\n  subscribe(pkt) :: return this._disp_send('subscribe', pkt, pkt)\n  unsubscribe(pkt) :: return this._disp_send('unsubscribe', pkt, pkt)\n\n  async _disp_send(type, pkt, key) ::\n    const res = this._disp_.future(key)\n    await this._send(type, pkt)\n    return res\n\n  static with_api(api) ::\n    class MQTTClient extends this ::\n    Object.assign @ MQTTClient.prototype, api\n    return MQTTClient\n\n\nObject.assign @ MQTTClient.prototype, @{}\n  _transport: _mqtt_client_transport\n  _dispatch: _mqtt_client_dispatch\n\n\nexport function _mqtt_client_transport(client) ::\n  const q = [] // tiny version of deferred\n  q.then = y => void q.push(y)\n  q.notify = v => :: for const fn of q.splice(0,q.length) :: fn(v)\n\n  const send0 = @\\ type, pkt ::>\n    (await q)(type, pkt)\n\n  client._send = send0\n  return @{}\n    is_live: @=> send0 !== client._send\n    reset() :: client._send = send0\n\n    set(mqtt_session, send_u8_pkt) ::\n      const [mqtt_decode, mqtt_encode] =\n        mqtt_session()\n\n      const on_mqtt_chunk = u8_buf =>\n        client._on_mqtt @\n          mqtt_decode(u8_buf)\n          client\n\n      const send_pkt = @\\ type, pkt ::>\n        send_u8_pkt @\n          mqtt_encode(type, pkt)\n\n\n      client._send = send_pkt\n      q.notify(send_pkt)\n      return on_mqtt_chunk\n\n\n\nexport const _mqtt_client_cmdid_dispatch = @{}\n  get on_mqtt() ::\n    const {cmdids, rotate:{td,n} } = this\n    let ts = td + Date.now()\n    return @\\ pkt_list ::\n      for const pkt of pkt_list ::\n        cmdids[pkt.id] @ this, pkt\n\n      if Date.now() > ts ::\n        this.rotate_belt(n)\n        ts = td + Date.now()\n\n\n  resolve(key, pkt) ::\n    for const map of this.hashbelt ::\n      const entry = map.get(key)\n      if undefined !== entry ::\n        map.delete(key)\n        entry[0] @ pkt\n        return true\n    return false\n\n  rotate: @{} n: 3, td: 1000 // 3 * 1s buckets\n  rotate_belt(n) ::\n    const {hashbelt} = this\n    hashbelt.unshift @ new Map()\n    for const old of hashbelt.splice(n) ::\n      for const entry of old.values() ::\n        entry[1]('expired')\n\n  cmdids: @!\n    return @[]\n      by_evt   // 0x0 reserved\n      by_evt   // 0x1 connect\n      by_type  // 0x2 connack\n      by_evt   // 0x3 publish\n      by_id    // 0x4 puback\n      by_id    // 0x5 pubrec\n      by_id    // 0x6 pubrel\n      by_id    // 0x7 pubcomp\n      by_evt   // 0x8 subscribe\n      by_id    // 0x9 suback\n      by_evt   // 0xa unsubscribe\n      by_id    // 0xb unsuback\n      by_evt   // 0xc pingreq\n      by_evt   // 0xd pingresp\n      by_evt   // 0xe disconnect\n      by_type  // 0xf auth\n\n\n    function by_id(disp, pkt) ::\n      disp.resolve @ pkt.pkt_id, pkt\n\n    function by_type(disp, pkt) ::\n      disp.resolve @ pkt.type_obj.type, pkt\n      by_evt(disp, pkt)\n\n    async function by_evt({target}, pkt) ::\n      const fn = target[`mqtt_${pkt.type_obj.type}`]\n      if undefined !== fn ::\n        await fn.call(target, pkt)\n      else ::\n        await target.mqtt_pkt(pkt)\n\n\n\nexport function _mqtt_client_dispatch(client, target) ::\n  if null == target ::\n    target = client\n  else if 'function' === typeof target ::\n    target = {mqtt_pkt: target}\n\n\n  const hashbelt = [new Map()]\n  let _hb_key, _pkt_id=100\n  const _deferred_by_key = (...args) =>\n    hashbelt[0].set(_hb_key, args)\n\n  const _disp_ = @{}\n    __proto__: _mqtt_client_cmdid_dispatch\n    target, hashbelt,\n\n    future(pkt_or_key) ::\n      if 'string' === typeof pkt_or_key ::\n        _hb_key = pkt_or_key\n      else ::\n        _pkt_id = (_pkt_id + 1) & 0xffff\n        _hb_key = pkt_or_key.pkt_id = _pkt_id\n\n      return new Promise(_deferred_by_key)\n\n  client._on_mqtt = _disp_.on_mqtt\n  return _disp_\n\n","import {connect as net_connect} from 'net'\nexport {MQTTClient} from './core.jsy'\n\nexport function _mqtt_node_api(mqtt_session) ::\n  return @{}\n    with_tcp(...args) ::\n      if 0 === args.length ::\n        args = @[] 1883, '127.0.0.1'\n\n      return this.with_stream @ net_connect(...args)\n\n    with_stream(duplex_stream, passthrough) ::\n      const on_mqtt_chunk = this._conn_.set @\n        mqtt_session\n        u8_pkt => duplex_stream.write(u8_pkt)\n\n      duplex_stream.once @ 'end', this._conn_.reset\n\n      this._msg_loop = passthrough\n        ? _aiter_msg_loop(duplex_stream, on_mqtt_chunk)\n        : _async_msg_loop(duplex_stream, on_mqtt_chunk)\n\n      return this\n\n\nasync function _async_msg_loop(duplex_stream, on_mqtt_chunk) ::\n  for await const chunk of duplex_stream ::\n    on_mqtt_chunk @ chunk\n\nasync function * _aiter_msg_loop(duplex_stream, on_mqtt_chunk) ::\n  for await const chunk of duplex_stream ::\n    on_mqtt_chunk @ chunk\n    yield chunk\n\n","import {mqtt_session} from '../session.jsy'\nimport {MQTTClient, _mqtt_node_api} from './core_node.jsy'\n\nexport default MQTTClient.with_api @\n  _mqtt_node_api(mqtt_session)\n\n"],"names":["mqtt_decode_pubrec","mqtt_decode_pubrel","mqtt_decode_pubcomp","net_connect"],"mappings":"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"}