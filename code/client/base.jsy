const _c_pub = 'publish'

export class MQTTBaseClient ::
  constructor(target) ::
    this._conn_ = this._transport(this)
    this._disp_ = this._dispatch(this, target)


  auth(pkt) :: return this._disp_send('auth', pkt, 'auth')
  connect(pkt) :: return this._disp_send('connect', pkt, 'connack')
  disconnect(pkt) :: return this._send('disconnect', pkt)

  subscribe(pkt, ex) ::
    pkt = _as_topics(pkt, ex)
    return this._disp_send('subscribe', pkt)
  unsubscribe(pkt, ex) ::
    pkt = _as_topics(pkt, ex)
    return this._disp_send('unsubscribe', pkt)

  publish(pkt) :: return _pub @ this, pkt.qos, pkt
  post(topic, payload) :: return _pub @ this, 0, {topic, payload}
  send(topic, payload) :: return _pub @ this, 1, {topic, payload}
  json_post(topic, msg) :: return _pub @ this, 0, {topic, msg}
  json_send(topic, msg) :: return _pub @ this, 1, {topic, msg}

  /* async _send(type, pkt) -- provided by _transport */
  /* _on_mqtt(pkt_list, self) -- provided by _dispatch */

  async _disp_send(type, pkt, key) ::
    const res = this._disp_.future(key || pkt)
    await this._send(type, pkt)
    return res


function _pub(self, qos, pkt) ::
  const {msg} = pkt
  if undefined !== msg ::
    pkt.payload = JSON.stringify(msg)
  return qos > 0
    ? self._disp_send(_c_pub, pkt)
    : self._send(_c_pub, pkt)

function _as_topics(pkt, ex) ::
  if 'string' === typeof pkt ::
    return {topics:[pkt], ... ex}
  if pkt[Symbol.iterator] ::
    return {topics:[... pkt], ... ex}
  return ex ? {...pkt, ...ex} : pkt

