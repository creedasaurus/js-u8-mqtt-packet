const _c_pub = 'publish'

export class MQTTBaseClient ::
  constructor(target) ::
    this._conn_ = this._transport(this)
    this._disp_ = this._dispatch(this, target)

  /* async _send(type, pkt) -- provided by _transport */
  /* _on_mqtt(pkt_list, self) -- provided by _dispatch */

  auth(pkt) :: return this._disp_send('auth', pkt, 'auth')
  connect(pkt) :: return this._disp_send('connect', pkt, 'connack')

  disconnect(pkt) :: return this._send('disconnect', pkt)
  publish(pkt) ::
    return pkt.qos > 0 
      ? this._disp_send(_c_pub, pkt)
      : this._send(_c_pub, pkt)

  post(topic, payload) ::
    return this._send @ _c_pub,
      @{} topic, payload, qos:0
  send(topic, payload) ::
    return this._disp_send @ _c_pub,
      @{} topic, payload, qos:1

  subscribe(pkt, ex) ::
    pkt = _as_topics(pkt, ex)
    return this._disp_send('subscribe', pkt)
  unsubscribe(pkt, ex) ::
    pkt = _as_topics(pkt, ex)
    return this._disp_send('unsubscribe', pkt)

  async _disp_send(type, pkt, key) ::
    const res = this._disp_.future(key || pkt)
    await this._send(type, pkt)
    return res


function _as_topics(pkt, ex) ::
  if 'string' === typeof pkt ::
    return {topics:[pkt], ... ex}
  if pkt[Symbol.iterator] ::
    return {topics:[... pkt], ... ex}
  return ex ? {...pkt, ...ex} : pkt

