
export function _mqtt_client_dispatch(client, target) ::
  if null == target ::
    target = @{} __proto__: client
  else if 'function' === typeof target ::
    target = {mqtt_pkt: target}


  const hashbelt = [new Map()]
  let _hb_key, _pkt_id=100
  const _deferred_by_key = (...args) =>
    hashbelt[0].set(_hb_key, args)

  const _disp_ = @{}
    __proto__: _mqtt_client_cmdid_dispatch
    target, hashbelt,

    future(pkt_or_key) ::
      if 'string' === typeof pkt_or_key ::
        _hb_key = pkt_or_key
      else ::
        _pkt_id = (_pkt_id + 1) & 0xffff
        _hb_key = pkt_or_key.pkt_id = _pkt_id

      return new Promise(_deferred_by_key)

  client._on_mqtt = _disp_.on_mqtt
  return _disp_


export const _mqtt_client_cmdid_dispatch = @{}
  get on_mqtt() ::
    const {cmdids, rotate:{td,n} } = this
    let ts = td + Date.now()
    return @\ pkt_list, client ::
      for const pkt of pkt_list ::
        cmdids[pkt.id] @ this, pkt, client

      if Date.now() > ts ::
        this.rotate_belt(n)
        ts = td + Date.now()


  resolve(key, pkt) ::
    for const map of this.hashbelt ::
      const entry = map.get(key)
      if undefined !== entry ::
        map.delete(key)
        entry[0] @ pkt
        return true
    return false

  rotate: @{} n: 3, td: 1000 // 3 * 1s buckets
  rotate_belt(n) ::
    const {hashbelt} = this
    hashbelt.unshift @ new Map()
    for const old of hashbelt.splice(n) ::
      for const entry of old.values() ::
        entry[1]('expired')

  cmdids: @!
    return @[]
      by_evt   // 0x0 reserved
      by_evt   // 0x1 connect
      by_type  // 0x2 connack
      by_evt   // 0x3 publish
      by_id    // 0x4 puback
      by_id    // 0x5 pubrec
      by_id    // 0x6 pubrel
      by_id    // 0x7 pubcomp
      by_evt   // 0x8 subscribe
      by_id    // 0x9 suback
      by_evt   // 0xa unsubscribe
      by_id    // 0xb unsuback
      by_evt   // 0xc pingreq
      by_evt   // 0xd pingresp
      by_evt   // 0xe disconnect
      by_type  // 0xf auth


    function by_id(disp, pkt) ::
      disp.resolve @ pkt.pkt_id, pkt

    function by_type(disp, pkt, client) ::
      disp.resolve @ pkt.type_obj.type, pkt
      by_evt(disp, pkt, client)

    async function by_evt({target}, pkt, client) ::
      const fn = target[`mqtt_${pkt.type_obj.type}`]
        || target.mqtt_pkt

      if undefined !== fn ::
        await fn.call(target, pkt, client)

