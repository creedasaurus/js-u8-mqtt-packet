
export class MQTTClient ::
  constructor(target) ::
    this._conn_ = this._transport(this)
    this._disp_ = this._dispatch(this, target)

  /* async _send(type, pkt) -- provided by _transport */
  /* _on_mqtt(pkt_list, self) -- provided by _dispatch */

  auth(pkt) :: return this._disp_send('auth', pkt, 'auth')
  connect(pkt) :: return this._disp_send('connect', pkt, 'connack')

  disconnect(pkt) :: return this._send('disconnect', pkt)
  publish(pkt) ::
    return pkt.qos > 0 
      ? this._disp_send('publish', pkt, pkt)
      : this._send('publish', pkt)

  subscribe(pkt) :: return this._disp_send('subscribe', pkt, pkt)
  unsubscribe(pkt) :: return this._disp_send('unsubscribe', pkt, pkt)

  async _disp_send(type, pkt, key) ::
    const res = this._disp_.future(key)
    await this._send(type, pkt)
    return res

  static with_api(api) ::
    class MQTTClient extends this ::
    Object.assign @ MQTTClient.prototype, api
    return MQTTClient


Object.assign @ MQTTClient.prototype, @{}
  _transport: _mqtt_client_transport
  _dispatch: _mqtt_client_dispatch


export function _mqtt_client_transport(client) ::
  const q = [] // tiny version of deferred
  q.then = y => void q.push(y)
  q.notify = v => :: for const fn of q.splice(0,q.length) :: fn(v)

  const send0 = @\ type, pkt ::>
    (await q)(type, pkt)

  client._send = send0
  return @{}
    is_live: @=> send0 !== client._send
    reset() :: client._send = send0

    set(mqtt_session, send_u8_pkt) ::
      const [mqtt_decode, mqtt_encode] =
        mqtt_session()

      const on_mqtt_chunk = u8_buf =>
        client._on_mqtt @
          mqtt_decode(u8_buf)
          client

      const send_pkt = @\ type, pkt ::>
        send_u8_pkt @
          mqtt_encode(type, pkt)


      client._send = send_pkt
      q.notify(send_pkt)
      return on_mqtt_chunk



export const _mqtt_client_cmdid_dispatch = @{}
  get on_mqtt() ::
    const {cmdids, rotate:{td,n} } = this
    let ts = td + Date.now()
    return @\ pkt_list ::
      for const pkt of pkt_list ::
        cmdids[pkt.id] @ this, pkt

      if Date.now() > ts ::
        this.rotate_belt(n)
        ts = td + Date.now()


  resolve(key, pkt) ::
    for const map of this.hashbelt ::
      const entry = map.get(key)
      if undefined !== entry ::
        map.delete(key)
        entry[0] @ pkt
        return true
    return false

  rotate: @{} n: 3, td: 1000 // 3 * 1s buckets
  rotate_belt(n) ::
    const {hashbelt} = this
    hashbelt.unshift @ new Map()
    for const old of hashbelt.splice(n) ::
      for const entry of old.values() ::
        entry[1]('expired')

  cmdids: @!
    return @[]
      by_evt   // 0x0 reserved
      by_evt   // 0x1 connect
      by_type  // 0x2 connack
      by_evt   // 0x3 publish
      by_id    // 0x4 puback
      by_id    // 0x5 pubrec
      by_id    // 0x6 pubrel
      by_id    // 0x7 pubcomp
      by_evt   // 0x8 subscribe
      by_id    // 0x9 suback
      by_evt   // 0xa unsubscribe
      by_id    // 0xb unsuback
      by_evt   // 0xc pingreq
      by_evt   // 0xd pingresp
      by_evt   // 0xe disconnect
      by_type  // 0xf auth


    function by_id(disp, pkt) ::
      disp.resolve @ pkt.pkt_id, pkt

    function by_type(disp, pkt) ::
      disp.resolve @ pkt.type_obj.type, pkt
      by_evt(disp, pkt)

    async function by_evt({target}, pkt) ::
      const fn = target[`mqtt_${pkt.type_obj.type}`]
      if undefined !== fn ::
        await fn.call(target, pkt)
      else ::
        await target.mqtt_pkt(pkt)



export function _mqtt_client_dispatch(client, target) ::
  if null == target ::
    target = client
  else if 'function' === typeof target ::
    target = {mqtt_pkt: target}


  const hashbelt = [new Map()]
  let _hb_key, _pkt_id=100
  const _deferred_by_key = (...args) =>
    hashbelt[0].set(_hb_key, args)

  const _disp_ = @{}
    __proto__: _mqtt_client_cmdid_dispatch
    target, hashbelt,

    future(pkt_or_key) ::
      if 'string' === typeof pkt_or_key ::
        _hb_key = pkt_or_key
      else ::
        _pkt_id = (_pkt_id + 1) & 0xffff
        _hb_key = pkt_or_key.pkt_id = _pkt_id

      return new Promise(_deferred_by_key)

  client._on_mqtt = _disp_.on_mqtt
  return _disp_

