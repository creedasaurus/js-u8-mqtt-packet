import {createWriteStream} from 'fs'
import {pipeline} from 'stream'
import {createServer, connect} from 'net'
const mqtt_pkt = require('mqtt-packet')

import {mqtt_aiter_decoder, mqtt_encode_by_name} from 'u8-mqtt-packet'

const mitm_port = parseInt(process.argv.slice(2).pop() || 1884)

createServer()
  .on @ 'error', @\ err ::
    console.warn @ 'Error on server:', err

  .on @ 'listening', @::
    console.log @ 'Ready'

  .on @ 'connection', @\ sock_src ::
    console.log @ 'Host Conn', typeof sock_src

    const sock_dst = connect @ 1883, '127.0.0.1', @::
      console.log @ 'MQTT Conn', typeof sock_dst

      const ts_log = createWriteStream @
        `logs/mqtt.${Date.now().toString(36)}.log.json`

      const info = @{} mitm_port
      ts_log.write @ `{"info":${JSON.stringify(info)}, "mqtt_log":[\n`

      const ctx={}

      pipeline @
        sock_src

        async function *(stream) ::
          for await const chunk of stream ::
            ts_log.write @ `  {"cs": "${chunk.toString('hex')}"},\n`
            yield new Uint8Array @ chunk

        mqtt_aiter_decoder @ ctx, @\ pkt_lst ::
          for const pkt of pkt_lst ::
            const {mqtt_level, type_obj, u8_body, u8_raw_pkt, ...tip} = pkt
            if 0 ::
              console.log @ '==>', tip
            else ::
              rt_pkt(type_obj, tip, u8_raw_pkt, mqtt_level)

        sock_dst

        async function *(stream) ::
          for await const chunk of stream ::
            ts_log.write @ `  {"sc": "${chunk.toString('hex')}"},\n`
            yield new Uint8Array @ chunk

        mqtt_aiter_decoder @ ctx, @\ pkt_lst ::
          for const pkt of pkt_lst ::
            const {mqtt_level, type_obj, u8_body, u8_raw_pkt, ...tip} = pkt
            if 0 ::
              console.log @ '<--', tip
            else ::
              rt_pkt(type_obj, tip, u8_raw_pkt, mqtt_level)

        sock_src

        @\ err ::>
          ts_log.write @ `  null ]}\n`
          ts_log.end()

          sock_dst.end()
          sock_src.end()

          if err ::
            console.warn @ 'Error at end of pipeline:', err

  .listen @ mitm_port


function rt_pkt(type_obj, tip, u8_raw_pkt, mqtt_level) ::
  if ['publish', 'connect'].includes @ type_obj.type ::
    console.log @ "IG", type_obj
    return

  const fn_encode = mqtt_encode_by_name[type_obj.type]
  const rt_pkt = fn_encode(tip)
  if undefined === rt_pkt ::
    console.log @ 'No RT', type_obj
    return

  const diff = rt_pkt.map @\ v,i => v === u8_raw_pkt[i] ? 0 : 1
  const eq = u8_raw_pkt.byteLength === rt_pkt.byteLength 
    && ! diff.some(Boolean)

  console.group @ 'RT', eq, mqtt_level, type_obj
  if ! eq ::
    console.log @ 'tip', tip
    console.log @ 'rt_pkt', rt_pkt
    console.log @ 'or_pkt', u8_raw_pkt
    console.log @ 'diff', diff

    mqtt_pkt.parser()
    .on @ 'packet', pkt_o =>
      console.log @ '3p', pkt_o
    .parse @ Buffer.from(u8_raw_pkt)

  console.groupEnd()

